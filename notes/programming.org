* How does a concurrent garbage collector work

[[https://blog.pusher.com/golangs-real-time-gc-in-theory-and-practice/]]

In golang, its collector runs concurrently with the program. It is called
/tricolor mark-and-sweep/ algorithm.

It enables the GC to run concurrently with the program; and means that the pause
times become a *scheduling* problem. The scheduler can be configured to only run
GC for short periods of time, /*interleaved*/ with the program.

The details of the algorithm is illustrated in link above.

** Overview of the steps
- The garbage collector assigns objects to three sets: *black*, *grey*,
  and *white*. At the beginning of a GC cycle, all objects are put in white set;
- Any newly created object are put in the grey set; The rule is: when a pointer
  field is changed, the pointed-to object is coloured;
- At the start of a GC cycle, the root objects are moved to the grey set;
- To scan an object, the collector colours it black, and its children grey;
  At any stage, we can count the number of moves the GC has left to do:
  ~2*|white| + |grey|~. The collector finished when it reach zero;
- When there is no more grey objects to scan, the white objects are unreachable,
  and available for free;
- Swap white and black set for the next GC cycle;
- The GC still has to stop-the-world while scanning for root objects; however in
  practice the pause time is <1ms for very large heaps.

Low latency has costs, the most important cost is reduced /throughput/.
Concurrency requires extra work for synchronisation and duplication, which eats
into the time program can do useful work.

** Some benchmarks

| Benchmark   | Longest pause (ms) |
| OCaml       |               2.21 |
| Golang      |               7.01 |
| Java 1.8    |                161 |
| Java 1.8 G1 |                153 |

Java perform very poorly compared.

** Takeaway
GC are either optimised for low latency or high throughput. It is important to
understand the underlying GC algorithm in order to decide whether it is
appropriate  for your use-case.
