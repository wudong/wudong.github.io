<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Programming in scala | Warren Liu</title>
<link href="../../../assets/css/rst.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/poole.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/lanyon.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/custom.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">
<link rel="canonical" href="https://wudong.graceliu.uk/posts/reading/programming-in-scala/">
<!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Warren Liu">
<link rel="prev" href="../redis-in-action/" title="Redis in Action" type="text/html">
<link rel="next" href="../play-for-scala/" title="Play for Scala" type="text/html">
<meta property="og:site_name" content="Warren Liu">
<meta property="og:title" content="Programming in scala">
<meta property="og:url" content="https://wudong.graceliu.uk/posts/reading/programming-in-scala/">
<meta property="og:description" content="Table of Contents


Function
Class and Trait
Pattern Matching







Function


Define function:
  def max(x: Int, y: Int): Int = {
     if (x&gt;y) x
     else y
  }


If a function consists of just one">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2017-07-15T00:00:00+01:00">
<meta property="article:tag" content="scala">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
            styles, `#sidebar-checkbox` for behavior. -->
    <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox"><!-- Toggleable sidebar --><div class="sidebar" id="sidebar">
        <div class="sidebar-item">
            <p>A reserved <a href="https://getnikola.com" target="_blank">Nikola</a> theme that places the utmost gravity on content with a hidden drawer. Made by <a href="https://twitter.com/mdo" target="_blank">@mdo</a> for Jekyll,
            ported to Nikola by <a href="https://twitter.com/ralsina" target="_blank">@ralsina</a>.</p>
        </div>
        
    <nav id="menu" role="navigation" class="sidebar-nav"><a class="sidebar-nav-item" href="../../../archive.html">Archive</a>
        <a class="sidebar-nav-item" href="../../../categories/">Tags</a>
        <a class="sidebar-nav-item" href="../../../rss.xml">RSS feed</a>
    
    
    </nav>
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          
    <h3 id="brand" class="masthead-title">
      <a href="https://wudong.graceliu.uk/" title="Warren Liu" rel="home">Warren Liu</a>
    </h3>

        </div>
      </div>

      <div class="container content" id="content">
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="post-title p-name entry-title" itemprop="headline name"><a href="." class="u-url">Programming in scala</a></h1>

        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Warren Liu</span></p>
            <p class="dateline"><a href="." rel="bookmark"><time class="post-date published dt-published" datetime="2017-07-15T00:00:00+01:00" itemprop="datePublished" title="2017-07-15 00:00">2017-07-15 00:00</time></a></p>
        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Function</a></li>
<li><a href="#sec-2">Class and Trait</a></li>
<li><a href="#sec-3">Pattern Matching</a></li>
</ul>
</div>
</div>



<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Function</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>Define function:
<div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">max</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">&gt;</span><span class="n">y</span><span class="o">)</span> <span class="n">x</span>
     <span class="k">else</span> <span class="n">y</span>
  <span class="o">}</span>
</pre></div>
</li>
<li>If a function consists of just one statement, the curly braces can
be omitted.
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">max2</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">&gt;</span><span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span>
</pre></div>
</li>
<li>Scala's Unit type is similar to Java's void type.
</li>
<li>Functions are first class constructs; for example:
<div class="highlight"><pre><span></span><span class="n">args</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">arg</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span>
</pre></div>
<p>
In this case, a function literal that take one parameter named <code>arg</code>
is passed in; the body of the function is <code>println(arg)</code>.
</p>
</li>
<li>In the above example, Scala infers the type of arg to be String,
since String is the element type of the array on which you are
calling foreach. but you can also do more explicitly:
<div class="highlight"><pre><span></span><span class="n">args</span><span class="o">.</span><span class="n">foreach</span><span class="o">((</span><span class="n">arg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span>
</pre></div>
</li>
<li>If a function literal consists of one statement that takes a single
argument, you dont need to explicitly name and specify the argument. Thus
the following code also works:
<div class="highlight"><pre><span></span><span class="n">args</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</pre></div>
</li>
<li>The traditional for loop can be written as like:
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</pre></div>
<p>
the arg to the left of &lt;- is a val, not a var: arg can't be
reassigned inside the body of the for expression.
</p>
</li>
<li>The generic in scala:
<div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">greetingStrings</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span>
</pre></div>
<p>
and to access the array content using parentheses, not square
brackets as in Java:
</p>
<div class="highlight"><pre><span></span><span class="n">greetStrings</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="s">"Hello"</span>
</pre></div>
<p>
The for expression that access the array:
</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">2</span><span class="o">)</span> <span class="n">print</span><span class="o">(</span><span class="n">grentStrings</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
</pre></div>
</li>
<li>As a <b>general rule</b> in scala:  if a method takes only one parameter,
you can call it without a dot or a parentheses. In the above example
the <code>to</code> in is actually a method that takes one Int argument. thus 0 to
2 is actually a method call <code>(0).to(2)</code>.
</li>
<li>Note that this syntax only works if you explicitly specify the
receiver of the method call. You cannot write <code>println 10</code>, but you
can write <code>Console println 10</code>.
</li>
<li>Scala doesn't technically have operator overloading, because it
doesn't actually have operators in the traditional sense. Instead,
characters such as +, -, * and / can be used in method names.
</li>
<li>When you <b>apply parentheses</b> surrounding one or more values to a
variable, Scala will transform the code into an invocation of a
method named <code>apply</code> on that variable. So <code>greetStrings(i)</code> gets
transformed into <code>greetStrings.apply(i)</code>. Thus accessing an element of
an array in Scala is <i>simply a method</i> call like any other.
</li>
<li>Similarly, when an assignment is made to a variable to which
<b>parentheses and one more arguments</b> have been applied, the compiler
will transform that into an invocation of an <code>update</code> method. Thus 
<code>greetString(0) = 1</code> is transformed into: <code>greetStrings.update(0, 1)</code>
</li>
<li>To create and initialise arrays more easily:
<div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">numNames</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="s">"zero"</span><span class="o">,</span> <span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">)</span>
</pre></div>
<p>
In this case, Scala will actually call a <b>factory method</b>, named
<code>apply</code>, on Array type.
</p>
</li>
<li>Scala's array is a <b>mutable</b> sequence of objects that all share the
same type. Array[String] contains only strings; Although you can't
change the length of an array, you can change its element values. 
</li>
<li>For an immutable sequence of objects that share the same type, you
can use Scala's List class. <code>scala.List</code>, differs from Java's
java.util.List type in that Scala Lists are always <b>immutable</b>, in a
sense that, when you call a method on a list that might seem by its
name to imply the list will mutate, <span class="underline">it instead creates and returns a
new list with the new value</span>.
</li>
<li>If a method is used in operator notation, such as <code>a*b</code>, the method is
invoked on the left operand, as in <code>a.*(b)</code>, unless the method name
ends in a <b>colon</b>, where the method is invoked on the right operand.
</li>
<li>Scala's List can contains only same type elements, while <b>tuple</b> can
contains different types. To instantiate a new tuple that holds some
objects:
<div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">pair</span> <span class="k">=</span> <span class="o">(</span><span class="mi">99</span><span class="o">,</span> <span class="s">"Lu"</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
</pre></div>
<p>
Scala infers the type of the tuple to be Tuple2[Int, String] and
gives that type to variable pair. Note that these -N numbers
function to <i>access the element of a tuple</i> is <b>1</b> based,  instead of
zero-based.
</p>
</li>
<li>When dealing with map:
<div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">treasureMap</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="o">()</span>
<span class="n">treasuremap</span> <span class="o">+=</span>  <span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">"Go to island."</span><span class="o">)</span>
</pre></div>
<p>
the method ~-&gt;~ can be applied on any object in scala, which will
produce a <b>two element tuple</b>.
</p>
</li>
<li>Both <code>set</code> and <code>map</code> in Scala have mutable version and immutable
version, which resides in different package. When no import is used,
Scala will choose to use the immutable version.
</li>
<li>One telltale sign is that if code contains any vars, it is probably
in an imperative style. Thus one way to move towards a functional
style, is to try to program without vars. The reason Scala
encourages a functional style, in fact, is that the functional style
can help you write more understandable, less error-prone
</li>
<li>Another telltale sign of a function with side effects is that its
result type is Unit.
</li>
<li>One important characteristic of method parameters in Scala is that
they are vals, not vars. so you cannot reassign a parameter inside a
method in Scala.
</li>
<li>The recommended style for methods is to avoid having explicit, and
especially multiple, return statement. Instead, think of <span class="underline">each method
as an expression that yields one value, which is returned</span>. This
philosophy will encourage you to <b>make methods quite small</b>, to factor
large methods into multiple smaller ones.
</li>
<li>Methods with a result type of <code>Unit</code>, are executed for their side
affects. Another way to express such methods is to leave off the
result type and the equals sign, and enclose the body of the method
in curly braces. In this form, the method looks like a
procedure. For example:
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span> <span class="o">{</span><span class="n">sum</span> <span class="o">+=</span><span class="n">b</span><span class="o">}</span>
</pre></div>
<p>
Whenever you leave off the equals sign before the body of a
function, its <i>result type will definitely be <code>Unit</code></i>. This is true no
matter what the body contains, because Scala can/will convert any
type to Unit.
</p>
</li>
<li>Scala includes a special syntax for <b>raw strings</b>, which is started
and ended with three double quotation marks in a row. Inside a raw
string, | (pipe) at the front of each line and then a method
stripMargin can be called to remove the white space.
</li>
<li>Whenever you call a method that takes multiple arguments using
operator notation, you have to place those arguments in
parentheses. For example:
<div class="highlight"><pre><span></span><span class="n">s</span> <span class="n">indexOf</span> <span class="o">(</span><span class="sc">'o'</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
</pre></div>
</li>
<li>
<b>Prefix operators</b> are a shorthand way of invoking methods. In this
case, the name of the method has <b>unary_</b> pretended to the operator
character. For example, <code>-2.0</code> will be translated to
<code>(2.0).unary_-</code>. The <i>only identifiers</i> that can be used as prefix
operators are <b>+, -, ! and ~</b>.
</li>
<li>
<b>Postfix operators</b> are methods take no arguments, when they are
<span class="underline">invoked without a dot or parentheses</span>.
</li>
<li>In scala, you can also leave off empty parentheses on method
calls. The <i>convention</i> is that you <span class="underline">include parentheses if the mouthed
has side effects</span>, such as <code>println()</code>, but you can <span class="underline">leave them off if
the method has no side effects</span>, such as <code>toLowerCase</code> invoked on a
String.
</li>
<li>Any method that ends in a ":" character is invoked on its right
operand, passing in the left operand. 
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Class and Trait</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>
<b>Object equality</b> is compared with <code>==</code> or <code>!=</code>. To comparing <b>reference
equality</b>, use method <code>eq</code> and <code>ne</code>. However, eq and ne only apply to
objects that directly map to Java objects.
</li>
<li>When a <b>singleton</b> object shares the same name with a class, it is
called that class's <i>companion object</i>; and you must define both the
class and its companion object <i>in the same source file</i>. <span class="underline">A class and
its companion object can assess each other's private members</span>.
</li>
<li>Ond difference between classes and singleton objects is that
singleton objects cannot take parameters, cause you can't
instantiate a single object with the new keyword. 
</li>
<li>Each singleton object is implemented as an instance of a synthetic
class referenced from a static variable, so they have the same
initialisation semantics as java statics. In particular, a singleton
object is initialised the first time some code access it. 
</li>
<li>Scala implicitly imports members of packages <code>java.lang</code> and <code>scala</code>, as
well as the member of a singleton object named <b><code>Predef</code></b>.
</li>
<li>If a class doesn't have a body, u don't need to specify empty curly
braces. The identifiers in the parentheses after the class name are
called <b>class parameters</b>. Scala compiler will gather up these
class parameters and create a <b>primary constructor</b> that takes the
same two parameters. For example:
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</pre></div>
<p>
class parameters can be used directly in the body of the class.
</p>
</li>
<li>The scala compiler will compile any code you place in the class
body, <span class="underline">which isn't part of a field or a method definition</span>, into the
<b>primary constructor</b>.
</li>
<li>To override a method:
<div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">n</span> <span class="o">+</span><span class="s">"/"</span> <span class="nc">_d</span>
</pre></div>
</li>
<li>Check preconditions, using <code>require</code>:
<div class="highlight"><pre><span></span><span class="n">require</span> <span class="o">(</span><span class="n">d</span><span class="o">!=</span><span class="mi">0</span><span class="o">)</span>
</pre></div>
<p>
<code>IllegalArgumentException</code> will be raised when the condition fail.
</p>
</li>
<li>Class parameters can only be access by <code>this</code> object.
</li>
<li>In scala, constructors other than the primary constructor are called
<b>auxiliary constructors</b>, and it is defined like: 
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>  <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> 
</pre></div>
</li>
<li>Scala can do implicit conversion of type by:
<div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">def</span> <span class="n">intToRational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</pre></div>
<p>
Note that for an implicit conversion to work, it needs to be in
scape. if the implicit method definition inside class Rational, it
won't be in scope in the interpreter.
</p>
</li>
<li>Scala's control structures are <code>if</code>, <code>while</code>, <code>for</code>, <code>try</code>, <code>match</code> and
<code>function calls</code>. /Almost all Scala's control structures result in some
value/. 
</li>
<li>The <code>while</code> and <code>do-while</code> constructs are called "loops", not
expressions, because <i>they don't result in an interesting value</i>. The
type of result is <b>Unit</b>. Only one value exists for type Unit, it is
called unit value and is written <b>()</b>. <i>The exists of () is how Scala's
Unit different from Java's void</i>. 
</li>
<li>While in Java, <i>assignment results in the value assigned</i>, in Scala
<b>assignment always results in unit value ()</b>. Thus for example this
bit of code won't work:
<div class="highlight"><pre><span></span><span class="k">while</span> <span class="o">((</span><span class="n">line</span> <span class="k">=</span> <span class="n">readLine</span><span class="o">())</span> <span class="o">!=</span><span class="s">""</span><span class="o">)</span> <span class="n">println</span> <span class="o">(</span><span class="n">line</span><span class="o">)</span>
</pre></div>
<p>
It will cause infinite loop; cause any thing compared with a () will
result in true.
</p>
</li>
<li>for expression with a filter:
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">".scala"</span><span class="o">))</span> <span class="n">println</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
</pre></div>
<p>
more than one filters can be includes. 
</p>
</li>
<li>for expression can have more than one &lt;- to get nested "loops". 
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">".scala"</span><span class="o">);</span>
    <span class="n">line</span><span class="k">&lt;-</span><span class="n">fileLines</span><span class="o">(</span><span class="n">file</span><span class="o">)</span> <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="n">pattern</span><span class="o">))</span> <span class="o">..</span>
</pre></div>
</li>
<li>Mid-stream variable bindings in for expression:
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">{</span>
 <span class="n">file</span><span class="k">&lt;-</span><span class="n">filesHere</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">".scala"</span><span class="o">)</span>
 <span class="n">line</span><span class="k">&lt;-</span><span class="n">fileLInes</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
 <span class="n">trimmed</span> <span class="k">=</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span> <span class="k">if</span> <span class="n">trimmed</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="n">pattern</span><span class="o">)</span>
<span class="o">}...</span>
</pre></div>
</li>
<li>
<code>for .. yield...</code> to produce new collections. 
<div class="highlight"><pre><span></span>  <span class="k">for</span> <span class="o">{</span>
   <span class="n">file</span><span class="k">&lt;-</span> <span class="n">filesHere</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">".scala"</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">file</span>
</pre></div>
<p>
the type of resulting collection is based on the kind of collection processed.
</p>
</li>
<li>In scala, <i>throw is an expression that has a result type of
<b>Nothing</b></i>, although when throw happens, the result type is never
evaluated.
</li>
<li>As with most Scala control structures, <code>try-catch-finally</code> results in
a value. If an exception is thrown but not caught, the expression
has not result al all; <i>The value computed in the finally clause, if
there is one, is dropped</i>. Usually finally clauses do some kind of
clean up; they should not normally change the value computers in the
main body or a catch cause. 
</li>
<li>
<code>match</code> expression also result in a value. 
</li>
<li>Scala don't have break and continue.
</li>
<li>A <code>function literal</code> is compiled into a class that when instantiated
at runtime is a function value. Function literals exists in the
source code where function values exist as objects at runtime. 
</li>
<li>To make a <code>function literal</code> even more concise, you can use
<i>underscores as placeholders</i> for one or <b>more</b> parameters, so long as
<span class="underline">each parameter appears only one time within the function</span>
literal. for example: ~ _ &gt; 0~ is same as <code>x =&gt; x&gt;0</code>
</li>
<li>If the compiler cannot know enough of the type of the parameter when
placeholder is used, the type can be specified: 
<div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">f</span><span class="k">=</span> <span class="o">(</span><span class="k">_:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">+(</span><span class="k">_:</span> <span class="kt">Int</span><span class="o">)</span>
</pre></div>
</li>
<li>Multiple underscores means <i>multiple parameters</i>.
</li>
<li>You can also replace an entire parameter list with an underscore.
</li>
<li>The function value (the object) that's created at runtime from this
function literal is called a <code>closure</code>. The name arises from the act
of "closing" the function literal by "capturing" the hidings of its
free variables. A function literal with no free variables is called
a closed term; and any function literal with free variables, such as
(x: Int) =&gt; x + more,  is an open term. 
</li>
<li>What happens if the free variables are changed after the closure is
created? In Scala, the answer is that closure sees the
change. Change made by the closure to a captured variable are
visible outside the closure.
</li>
<li>Scala allows you to indicate that the last parameter to a function
may be repeated. This allow clients to pass variable length argument
lists to the function.
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">echo</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">String*</span><span class="o">)</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</pre></div>
</li>
<li>The type of args inside the echo function String* is actually
Array[String]. <i>However you cannot pass a Array[String] into that
function directly</i>. To accomplish this, you will need to append the
array argument with an colon and an _* symbol, like:
<div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">array</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="s">"B"</span><span class="o">)</span>
<span class="n">echo</span><span class="o">(</span><span class="n">array</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span>
</pre></div>
<p>
This notation tells the compiler to pass each element of array as
its own argument to echo, rather than all of it as a single
argument. 
</p>
</li>
<li>You can use Named arguments to change the order the parameter is
passed into a function:
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">speed</span><span class="o">(</span><span class="n">distance</span><span class="k">:</span> <span class="kt">Float</span><span class="o">,</span> <span class="n">time</span><span class="k">:</span> <span class="kt">Float</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">time</span>
<span class="n">speed</span><span class="o">(</span><span class="n">time</span><span class="k">=</span><span class="mi">10</span><span class="o">,</span> <span class="n">distance</span><span class="k">=</span><span class="mi">100</span><span class="o">)</span>
</pre></div>
</li>
<li>You can also define default parameter values for function
parameters. The argument for such a parameter can optionally be
omitted from a function call, in which case the corresponding
argument will be filled with the default.
</li>
<li>In any method invocation in Scala in which you are passing in
exactly one argument, you can opt to <i>use curly braces to surround
the argument instead of parentheses</i>. This enable client programmers
to <span class="underline">write function literals between curly braces</span>. 
</li>
<li>In scala, <b>by-name parameter</b> to <b>delay the function call</b> when
passing function value; the function value is not evaluated at the
point of function application, but instead is <i>evaluated at each use
within the function</i>.
</li>
<li>
<b>Case classes</b> are regular classes which export their constructor
parameters and which provide a recursive decomposition mechanism
via pattern matching. It makes only sense to <i>define case classes if
<b>pattern matching</b> is used to decompose data structures</i>. 
</li>
<li>Scala does not require that the new primitive is used to
facilitate the construction of case classes.
</li>
<li>Similar to  interfaces  in Java, traits are used to define object
types by specifying the signature of the supported methods. Unlike
Java, Scala allows traits to be partially implemented; i.e. it is
possible to define default implementations for some methods. In
contrast to  classes, traits may not have <i>constructor parameters</i>.
</li>
<li>Scala is very liberal when it comes to mixing <b>parameterless</b>
  and <b>empty-paren</b> methods.
<ul class="org-ul">
<li>In particular, you can override a
parameterless method with an empty-paren method, and vice versa.
</li>
<li>you can also leave off the empty parentheses on an invocation of
any function that takes no arguments. 
</li>
</ul>
</li>
<li>In Scala, any class will implicitly extends from scala.AnyRef, which
is same as class java.lang.Object.
</li>
<li>Filed can be used to override an <b>parameterless</b> method. But on the
other hand, it is <i>forbidden to define a field and method with the
same name in the same class, whereas it is allowed in Java</i>. 
</li>
<li>A parametric filed for class:
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ArrayElement</span> <span class="o">(</span>
   <span class="k">val</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Element</span>
</pre></div>
<ul class="org-ul">
<li>combine  the  definition  of a class parameter and a
field.
</li>
<li>You can also prefix a class parameter with <code>var</code>, in which case
the corresponding field would be reassignable.
</li>
<li>It is possible to add modifiers such as <code>private</code>, <code>protected</code>, or
<code>override</code> to these parametric fields, just as you can do for any
other class member.
</li>
</ul>
</li>
<li>Invoking superclass constructors:
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LineElement</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="n">s</span><span class="o">)){</span>
<span class="o">}</span>
</pre></div>
</li>
<li>For override modifier, Scala requires such a modifier for all
 members that override a concrete member in a parent
class. the modifier is optional if a member implements an
abstract member with the same name. The modifier is forbidden if a
member doesn't not override or implement some other member in a base
class.
</li>
<li>Traits let you modify the methods of a class, and they do so in a
way that allow you to stack those modifications with each other. 
</li>
<li>
<b>Stackable modification</b> of traits:
<div class="highlight"><pre><span></span>  <span class="k">trait</span> <span class="nc">Doubling</span> <span class="k">extends</span> <span class="nc">IntQueue</span> <span class="o">{</span>
     <span class="k">abstract</span> <span class="k">override</span> <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span><span class="k">super</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">)</span> <span class="o">}</span>
  <span class="o">}</span>
</pre></div>
<ul class="org-ul">
<li>
<code>super()</code> calls in traits are dynamically bound. it will work as
long as the traits is mixed in after another trait or class that
gives a concrete definition to the method.
</li>
<li>To tell the compiler you are doing this on purpose, you must mark
such methods as abstract override. This combination of modifiers
is only allowed for members of traits, not classes. 
</li>
</ul>
</li>
<li>When you call a method on a class with several  mixed-in traits, the
method in the <b>right furthest</b> traits will be called. If it has a
<code>super()</code> call, the left  to  it will be called, and so on. The
<i>order of mixed-in traits is important</i>.
</li>
<li>Scala compiler adds a <b>copy</b> method to a case class for making
copied instance that are same except one or two attributes are
different. The method works by using named and default parameters:
<code>op.copy(operator = "-")</code>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Pattern Matching</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>Scala's match never "fall through" into the next case. If none of
the patterns match, an exception named "MatchError" is thrown.
</li>
<li>A constant pattern matches only itself. Any literal can be used as a
constant.
</li>
<li>Any <code>val</code> or <b>singleton object</b> can be used as a constant. For
example, <code>Nil</code>, a singleton object, is a pattern that matches only
empty List.
</li>
<li>A <b>variable pattern</b> matches <i>any object</i>, just like a <b>wildcard</b> but
Scala bind the variable to whatever the object is. 
</li>
<li>How does Scala compiler know that "Pi" is a constant imported from
scala.math, and not a variable that stands for the selector value
itself? Scala uses a s impel  lexical rule for disambiguation:
<ul class="org-ul">
<li>a simple name starting with a lowercase letter is taken to be a
pattern variable;
</li>
<li>all other references  are taken to be constants. 
</li>
<li>Lower case  constant identifier  can be treated in pattern match with
a back tick syntax. back tick can also be used to treat a keyword as
an ordinary identifier: <br><code>Tread.`yield`()</code> treats yield as an identifier rather than a
keyword.
</li>
</ul>
</li>
<li>You can match against sequence type like List or Array just like you
match against case classes. you can also match against tuples.
</li>
<li>Typed pattern can be used as a convenient replacement for type tests
and type casts:
<div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">generalSize</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
     <span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>
     <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span>
     <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
  <span class="o">}</span>
</pre></div>
</li>
<li>Alternatively: <code>expr.isInstanceOf[String]</code> and
<code>expr.asInstanceOf[String]</code> can be used.
</li>
<li>Scala restricts patterns to be linear: a pattern variable may only
appear once in a pattern. However you can use <b>pattern guard</b>:
<div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">simplifyAdd</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
     <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">"+"</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">"*"</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
     <span class="k">case</span> <span class="o">-</span> <span class="k">=&gt;</span> <span class="n">e</span>
  <span class="o">}</span>
</pre></div>
<p>
The guard can be an arbitrary boolean expression. 
</p>
</li>
<li>A sealed class cannot have any new subclasses added except the ones
in the same file. This will help the scala compiler to detect the
missing cases in a pattern match.
</li>

<li>
<b>Implicit conversion</b> are governed by the following rules:
<ul class="org-ul">
<li>Only definitions marked implicit are available. 
</li>
<li>An inserted implicit conversion must be in scope as a single
identifier, or be associated with the source or target type of the
conversion.
</li>
<li>The compiler will also book look implicit definitions in the
companion object of the source or expected target type of the
conversion. There is no need to import the conversion separately
into your
</li>
<li>Only one implicit is tried at a time, however, the restriction can
be circumvent by having implicits take implicit parameters. 
</li>
</ul>
</li>
</ul>
</div>
</div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../../categories/scala/" rel="tag">scala</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../redis-in-action/" rel="prev" title="Redis in Action">Previous post</a>
            </li>
            <li class="next">
                <a href="../play-for-scala/" rel="next" title="Play for Scala">Next post</a>
            </li>
        </ul></nav></aside></article><footer id="footer"><p>Contents © 2017         <a href="mailto:wudong@graceliu.uk">Warren Liu</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
            
        </footer>
</div>
    </div>
    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
    
    
    
            <script src="../../../assets/js/jquery.min.js"></script><script src="../../../assets/js/moment-with-locales.min.js"></script><script src="../../../assets/js/fancydates.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</body>
</html>
