<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Java Concurrency | Warren Liu</title>
<link href="../../../assets/css/rst.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/poole.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/lanyon.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/custom.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">
<link rel="canonical" href="https://wudong.graceliu.uk/posts/notes/java-concurrency/">
<!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Warren Liu">
<link rel="prev" href="../java-hotspot-gc/" title="Java HotSpot VM GC Tunning Guide" type="text/html">
<link rel="next" href="../java-8-topics/" title="Java 8 Topics" type="text/html">
<meta property="og:site_name" content="Warren Liu">
<meta property="og:title" content="Java Concurrency">
<meta property="og:url" content="https://wudong.graceliu.uk/posts/notes/java-concurrency/">
<meta property="og:description" content="Table of Contents


Java Thread/Concurrency

Thread
Synchronization
Waiting and Notification
Concurrency Utilities and Executors
Synchronizers
The Locking Framework
LockSupport
Concurrent Collections
">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2017-07-14T00:00:00+01:00">
<meta property="article:tag" content="concurrency">
<meta property="article:tag" content="java">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
            styles, `#sidebar-checkbox` for behavior. -->
    <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox"><!-- Toggleable sidebar --><div class="sidebar" id="sidebar">
        <div class="sidebar-item">
            <p>A reserved <a href="https://getnikola.com" target="_blank">Nikola</a> theme that places the utmost gravity on content with a hidden drawer. Made by <a href="https://twitter.com/mdo" target="_blank">@mdo</a> for Jekyll,
            ported to Nikola by <a href="https://twitter.com/ralsina" target="_blank">@ralsina</a>.</p>
        </div>
        
    <nav id="menu" role="navigation" class="sidebar-nav"><a class="sidebar-nav-item" href="../../../archive.html">Archive</a>
        <a class="sidebar-nav-item" href="../../../categories/">Tags</a>
        <a class="sidebar-nav-item" href="../../../rss.xml">RSS feed</a>
    
    
    </nav>
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          
    <h3 id="brand" class="masthead-title">
      <a href="https://wudong.graceliu.uk/" title="Warren Liu" rel="home">Warren Liu</a>
    </h3>

        </div>
      </div>

      <div class="container content" id="content">
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="post-title p-name entry-title" itemprop="headline name"><a href="." class="u-url">Java Concurrency</a></h1>

        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Warren Liu</span></p>
            <p class="dateline"><a href="." rel="bookmark"><time class="post-date published dt-published" datetime="2017-07-14T00:00:00+01:00" itemprop="datePublished" title="2017-07-14 00:00">2017-07-14 00:00</time></a></p>
        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li>
<a href="#sec-1">Java Thread/Concurrency</a>
<ul>
<li><a href="#sec-1-1">Thread</a></li>
<li><a href="#sec-1-2">Synchronization</a></li>
<li><a href="#sec-1-3">Waiting and Notification</a></li>
<li><a href="#sec-1-4">Concurrency Utilities and Executors</a></li>
<li><a href="#sec-1-5">Synchronizers</a></li>
<li><a href="#sec-1-6">The Locking Framework</a></li>
<li><a href="#sec-1-7">LockSupport</a></li>
<li><a href="#sec-1-8">Concurrent Collections</a></li>
<li><a href="#sec-1-9">Atomic Variables</a></li>
<li><a href="#sec-1-10">Fork/Join</a></li>
<li><a href="#sec-1-11">CompletionService</a></li>
<li><a href="#sec-1-12">Testing Concurrent Applications</a></li>
</ul>
</li>
</ul>
</div>
</div>



<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Java Thread/Concurrency</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Thread</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Thread's <b>Execution State</b> with the <code>Thread.getState()</code> method
returns <code>Enum Thread.State</code>:
<dl class="org-dl">
<dt> NEW </dt>
<dd>not yet started
</dd>
<dt> RUNNABLE </dt>
<dd>executing
</dd>
<dt> BLOCKED </dt>
<dd>A thread that is blocked <b>waiting for a monitor locks</b>
</dd>
<dt> WAITING </dt>
<dd>waiting <b>indefinitely</b> for another thread to perform a
particular action. A thread is in this state due to
calling one of the following methods:
<ul class="org-ul">
<li>
<code>Object.wait()</code>
</li>
<li>
<code>Thread.join()</code>
</li>
<li>
<code>LockSupport.park()</code>
</li>
</ul>
</dd>
<dt> TIMED<sub>WAITING</sub>
</dt>
<dd>waiting with a specified waiting time.
<ul class="org-ul">
<li>Apart from the timeout version of the above methods,
<code>Thread.sleep()</code> also put thread into this state.
</li>
</ul>
</dd>
<dt> TERMINATED </dt>
<dd>exited
</dd>
<dt> (no term) </dt>
<dd>Notice the difference between <b>BLOCKED</b> and <b>WAITING</b>.
</dd>
<dt> (no term) </dt>
<dd>Differenct WAITING status:
<ul class="org-ul">
<li>STATE: <b>BLOCKED (on object monitor)</b> : waiting for monitor entry,
when using intrinsicLock, i.e., the <code>synchronized</code> keyword.
</li>
<li>STATE: <b>WAITING (parking)</b>: waiting on condition, when using locks
from <code>java.util.concurrent</code>.
</li>
</ul>
</dd>
</dl>
</li>

<li>Thread's priority is taken into consideration by OS's Scheduler.
<ul class="org-ul">
<li>
<code>void setPriority(int priority)</code> : take value between
<b>Thread.MIN<sub>PRIORITY</sub></b> and <b>Thread.MAX<sub>PRIORITY</sub></b>, and
Thread.NORMAL<sub>PRIORITY</sub>* identifies the default priority.
</li>
<li>On Linux, the default scheduler is <b>Completely Fair Scheduler</b>
<ul class="org-ul">
<li>References:
<ul class="org-ul">
<li>
<a href="https://en.wikipedia.org/wiki/Completely_Fair_Scheduler">https://en.wikipedia.org/wiki/Completely_Fair_Scheduler</a>
</li>
<li>
<a href="http://www.informit.com/articles/article.aspx?p=101760">http://www.informit.com/articles/article.aspx?p=101760</a>
</li>
<li>
<a href="http://www.linuxjournal.com/magazine/completely-fair-scheduler">http://www.linuxjournal.com/magazine/completely-fair-scheduler</a>
</li>
</ul>
</li>
<li>Use a <b>red-black tree</b> (self balanced binary tree) to sort process
according to its <b>execution time</b>.
</li>
<li>Process with lowest execution time is scheduled next to run.
</li>
<li>Process running exceeding the max execution time is reinserted
into the tree for further scheduling.
</li>
<li>If a process spends a lot of its time sleeping, then its spent
time value is low and it automatically gets the priority boost
when it finally needs it
</li>
</ul>
</li>
<li>On Windows, it is <b>multilevel feedback queue scheduler</b>
</li>
</ul>
</li>
<li>A <b>daemon thread</b> is a thread that acts as a helper to <b>nondaemon
thread</b> and <b>dies</b> automatically when the application's last
nondaemon thread dies so that the application can terminate.
</li>
<li>Application will not terminate when the nondaemon default main
thread terminates until all background nondaemon threads
terminate.
</li>
<li>Interrupting Threads
<ul class="org-ul">
<li>
<code>void interrupt()</code>
<ul class="org-ul">
<li>If this thread is <b>blocked</b> because a call to <code>wait()</code>, <code>sleep()</code>
or <code>join()</code> methods, the thread's <b>interrupted status</b> is
cleared and <b>InterruptedException</b> is thrown.
</li>
<li>If this thread is <b>blocked</b> in an I/O operation on an
<b>interruptible channel</b>, the channel will be closed, the
interrupt status will be set and the thread will receive a
<b>ClosedByInterruptException</b>.
</li>
<li>If the thread is blocked in a <b>Selector</b>, then the interrupt
status will be set and it will return immediately from the
selection operation. possilby with a non-zero value.
</li>
<li>Otherwise the interrupt status is set.
</li>
</ul>
</li>
<li>
<code>static boolean interrupted()</code>
<ul class="org-ul">
<li>Test whether the <b>current</b> thread has been interrupted. The
interrupted status of the thread is cleard by this method.
</li>
</ul>
</li>
<li>
<code>boolean isInterrupted()</code>
<ul class="org-ul">
<li>Test whether this thread has been interrupted. The interrupted
status of the thread is unaffected by this method.
</li>
</ul>
</li>
</ul>
</li>
<li>Joining Threads:
<ul class="org-ul">
<li>
<code>void join()</code> : The calling/current* thread will wait for <b>this</b>
thread to die. <b>InterruptedException</b> is thrown when any thread
interrupted the <b>current</b> thread.
</li>
<li>
<code>void join(long millis), void join(long millis, int nanos)</code> :
passing <code>0</code> to wait indefinitely.
</li>
<li>This implementation uses a loop of <code>this.wait</code> calls conditioned
on <code>this.isAlive</code>. As a thread terminates the <code>this.notifyAll</code>
method is invoked.
</li>
<li>
<span class="underline">It is recommended that <b>applications</b> not use <code>wait</code>, <code>notify</code>, or
<code>notifyAll</code> on Thread instances</span>.
</li>
</ul>
</li>
<li>
<b>Thread.UncaughtExceptionHandler</b>
<ul class="org-ul">
<li>A Thread can set a handler when this thread abruptly terminates
due to an uncaught exception.
</li>
<li>If the thread has not set a handler, its ThreadGroup (which
implements the Handler interface) acts as its handler.
</li>
<li>
<b>static void setDefaultUncaughtExceptionHandler()</b> to set a global
default handler for all thread and will be called when the thread
has no handler set, and when its thread group (including parent
thread groups) does not specialize its <code>uncaughtException</code> method.
</li>
</ul>
</li>
<li>
<b>ThreadGroup</b> can forms a tree like structure.
</li>
<li>Values stored in <b>thread-local</b> variables are not related.
</li>
<li>
<b>InheritableThreadLocal</b> : When a child thread is created, the child
receives <b>initial values</b> for all <b>inheritable thread-local
variables</b> for which the parent has values.
<ul class="org-ul">
<li>
<code>protected T childValue(T parentValue)</code>: method used to calculate the
child's initial value as a function of the parent's value at the
time the child thread is created. This is called from within the
parent thread before the child is started.
</li>
</ul>
</li>
<li>
<b>java.util.Timer</b> and <b>java.util.TimerTask</b> for simple job scheduler
<ul class="org-ul">
<li>Timer let you schedule TimerTask for future execution on a
background thread, which is known as the <i>task-execution thread</i>.
</li>
<li>Timer tasks may be scheduled for one-shot execution, or for
repeated execution at regular intervals.
</li>
<li>Timer scales to large numbers of concurrently scheduled timer
tasks. <i>Thousands of tasks should present no problem</i>.
</li>
<li>Timer can be set as a daemon which will make the <i>task-execution
thread</i> a daemon task.
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Synchronization</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>
<code>counter++</code> : although a it might look like a single operation, it
is actually three separate operations: read, add 1 and write. It is
not thread safe.
</li>
<li>The compiler, the Java virtual machine (JVM), and the operating
system can collaborate to cache a variable in a register or a
processor-local cacherather than rely on main memory.
<ul class="org-ul">
<li>
<b>Each thread</b> has its <b>own copy</b> of the variable.
</li>
<li>When one thread writes to this variable, it’s writing to its copy;
</li>
<li>Other threads are unlikely to see the update in their copies.
</li>
</ul>
</li>
<li>Synchronization properties:
<dl class="org-dl">
<dt> mutual exclusion </dt>
<dd>each thread is mutually excluded from
executing in critical section when another thread is inside the
critical section.
<ul class="org-ul">
<li>the lock is often referred to as <b>mutex lock</b>
</li>
</ul>
</dd>
<dt> property of visibility </dt>
<dd>ensures that a thread executing in a
critical section always sees the most recent changes to shared variables.
<ul class="org-ul">
<li>It reads these variable from main memory on entry and writes
values to main memory on exit.
</li>
<li>In practical terms, on current hardware, this typically causes
flushing of the CPU caches when a monitor is acquired and writes
to main memory when it is released, both of which are expensive.
</li>
</ul>
</dd>
</dl>
</li>
<li>Synchronisation is implemented using monitors. Each Java object is
associated with a monitor, which a thread can <b>lock</b> or <b>unlock</b>
by acquiring and releasing the monitor's lock (a token).
</li>
<li>When a thread attempts to acquire a lock that it already holds, the
request succeeds.
</li>
<li>
<code>java.lang.Thread</code> has a <code>static boolean holdsLock(Object o)</code> method
that returns <code>true</code> when the calling thread holds the lock on the
Object.
</li>
<li>A thread that has acquired a lock <b>doesn't</b> release this lock when
it calls one of the Thread's <code>sleep()</code> methods.
</li>
<li>
<code>volatile</code> exhibits the property of <b>visibility</b>.
<ul class="org-ul">
<li>Using volatile, forces all accesses (read or write) to the
volatile variable to occur to main memory, effectively keeping the
volatile variable out of CPU caches.
</li>
<li>Use <code>volatile</code> only when visibility is an issue.
</li>
<li>Only <b>field</b> can be declared as volatile, not on local variable.
</li>
<li>You can declare <code>double</code> and <code>long</code> fields to be <code>volatile</code>, but
should avoid on <b>32-bit</b> JVMs because it takes two operations to
access a <code>double</code> or <code>long</code> value.
</li>
<li>
<code>volatile</code> field cannot also be declared <code>final</code>. But this isn't a
problem because <code>final</code> field can be safely accessed without
synchronization.
</li>
<li>
<code>volatile</code> along can be thread unsafe if the operation involve the
volatile variable has multiple step. For example:
<ul class="org-ul">
<li>
<b>check-then-act</b>
</li>
<li>
<b>read-modify-write</b>
</li>
</ul>
</li>
<li>
<a href="http://stackoverflow.com/questions/3519664/difference-between-volatile-and-synchronized-in-java">http://stackoverflow.com/questions/3519664/difference-between-volatile-and-synchronized-in-java</a>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Waiting and Notification</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>The <code>wait/notify</code> enables one thread waits for a <b>condition</b> to
exist. And another thread to create the condition and then notify
the waiting thread.
</li>
<li>
<code>void wait()</code>: cause the current thread to wait until another thread
invokes the <code>notify()</code> or <code>notifyAll()</code>, or for some other thread to
interrupt the current thread while waiting.
</li>
<li>
<code>void notify()</code>: Wake up a <b>single</b> thread that's waiting on this
object's monitor.
<ul class="org-ul">
<li>If more than one threads are waiting on this object,
one(arbitrary) of them is chosen.
</li>
<li>The awakened thread will not be able to proceed until the current
thread relinquishes the lock on this object.
</li>
<li>A thread releases ownership of the monitor associated with the
object whose <code>wait()</code> method is called.
</li>
</ul>
</li>
<li>This API leverages an object's <b>condition queue</b>, which is a
data structure that stores threads waiting for a condition to exists.
<ul class="org-ul">
<li>The waiting threads are known as the <b>wait set</b>.
</li>
<li>Because the condition queue is tightly bound to an object's lock,
all methods in this API must be called from within a synchronized
context. The current thread must be the owner of the object's
monitor.
<div class="highlight"><pre><span></span><span class="kd">synchronized</span><span class="o">(</span><span class="n">obj</span><span class="o">){</span>
    <span class="k">while</span> <span class="o">(&lt;</span><span class="n">condition</span> <span class="n">does</span> <span class="n">not</span> <span class="n">hold</span><span class="o">)</span>
	<span class="n">obj</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
    <span class="c1">//perform an action that's appropriate to condition.</span>
<span class="o">}</span>
</pre></div>
<ul class="org-ul">
<li>Because of the possibility of <b>spurious wakeups</b>, a thread might
wakes up without being notified, interrupted, or timingout),
<code>wait()</code> is called from within the <code>while</code> loop.
</li>
<li>Never call a <code>wait()</code> outside a loop.
</li>
</ul>
</li>
<li>Otherwise <b>java.lang.IllegalMonitorStateException</b> is thrown.
</li>
</ul>
</li>
<li>In <b>java.util.concurrent.locks.Condition</b>, it factors out these
Object's monitor methods into distinct objects to give the effect of
having multiple <b>wait-sets</b> per object, by combining them with the
use of arbitrary <b>Lock</b> implementations.
</li>
<li>Where a <b>Lock</b> replaces the use of <code>synchronized</code> methods and
statements, a <b>Condition</b> replaces the use of the Object monitor
methods.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Concurrency Utilities and Executors</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>The <b>ExecutorService</b> extends <b>Executor</b>, is typically implemented
by a thread pool.
<ul class="org-ul">
<li>
<code>invokeAll</code>, <code>invokeAny</code> perform the bulk execution, executing a
collection of tasks and then waiting for at least one, or all, to
complete.
</li>
</ul>
</li>
<li>
<b>CompletionService</b> interface and its implementation
<b>ExecutorCompletionService</b>, arranges that submitted tasks are, upon
completion, placed on a queue accessible using
<ul class="org-ul">
<li>
<code>take()</code>: which will block until a result is available.
</li>
<li>
<code>poll()</code>: which will return <code>null</code> if no result is available.
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Synchronizers</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>Countdown Latches : causes one or more threads to wait at a <i>gate</i>
until another thread open this gate, at which point these other
threads can continue.
<ul class="org-ul">
<li>
<code>void await(), void await(long timeout, TimeUnit unit)</code>
</li>
<li>
<code>void countDown()</code>
</li>
</ul>
</li>
<li>Cyclic Barriers : lets a set of threads wait for each other to reach
a common barrier point.
<ul class="org-ul">
<li>Useful in <b>parallel decomposition</b> scenarios, where a lengthy task
is divided into subtasks whose individual results are later merged
into the overall result of the task.
</li>
<li>The barrier is <i>cyclic</i> because it can be reused after the waiting
threads are released.
</li>
<li>
<code>CyclicBarrier(int parties)</code> : specific number of parties( threads
working toward a common goal)
</li>
<li>
<code>CyclicBarrier(int parties, Runnable barrierAction)</code> : the
barrierAction is executed when the barrier is <i>tripped</i>.
</li>
<li>
<code>int await(), int ~await(long timeout, TimeUnit unit)</code> : force
the calling thread to wait until all parties have invoked
<code>await()</code> on this cyclic barrier.
<ul class="org-ul">
<li>the method return the arrival index of the calling thread, where
a index  <code>getParties() -1</code> indicates the first thread to arrive,
and <code>zero</code> indicates the last thread to arrive (countdown).
</li>
<li>The calling thread will <b>also stop waiting</b> when it, or <b>another
waiting thread</b> is interrupted, timeout, or <code>reset()</code> is called
on this cyclic barrier.
</li>
<li>If the calling thread on wait is interrupted, this thread will
throw <b>InterruptedException</b>, while other waiting thread will
throw <b>BrokenBarrierException</b>
</li>
</ul>
</li>
<li>
<code>boolean isBroken()</code> : return <code>true</code> when one or more parties
broke out of this barrier because of interruption or timeout
since the cyclic barrier was constructed, or last reset.
</li>
<li>
<code>void reset()</code> : reset the barrier to its initial state. If any
parties are currently waiting at the barrier, they will return
with a <b>BrokenBarrierException</b>.
</li>
</ul>
</li>
<li>Exchangers :provides a synchronization point where threads can swap
objects.
<ul class="org-ul">
<li>Each thread presents some boject on entry to the exchanger's
<code>exchange()</code> method, matches with a partner thread, and receives
its partner's object on return.
</li>
<li>Useful in applications such as genetic algorithms and pipeline
design.
</li>
<li>
<code>java.util.concurrent.Exchanger&lt;V&gt;</code> has <code>V exchange(V x)</code> method:
wait for another thread to arrive at this exchange point and then
transfer the given object to it, receiving the other thread's
object in return.
<ul class="org-ul">
<li>If another thread is already waiting at the exchange point:
<ul class="org-ul">
<li>It is resumed for thread-scheduling purposes and receives the
object passed in by the calling thread.
</li>
<li>The current threads return immediately.
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Semaphores : maintains a set of <b>permits</b> for restricting the member
of threads that can access a limited resource.
<ul class="org-ul">
<li>A thread attempting to acquire a permit when no permits are
available blocks until some other thread releases a permit.
</li>
<li>Semaphores whose values can be more than 1 are known as <b>counting
semaphores</b>
</li>
<li>Semaphores whoese value can be only 0 or 1 are known as <b>binary
semaphores</b>, or <b>mutexes</b>.
</li>
<li>Semaphore can set to be fair (fairness policy) :
<ul class="org-ul">
<li>when <code>false</code>, i.e., not fair, it makes no guarantees about the
order in which threads acquire permites.
</li>
<li>when <code>true</code>, it guarantees the order as in FIFO, i.e., the first
thread invoking <code>acquire()</code> will get the permit first.
</li>
<li>Generally, semaphores used to control resource access should be
initialized as fair (<b>by default, it is not</b>) to ensure that no
therad is starved out from accessing a resource.
</li>
<li>When using semaphores for other kinds of synchronization
control, the throughput advantages of unfair ordering often
outweight fairness considerations.
</li>
<li>
<code>void acquire()</code>, <code>void acquire(int permits)</code>
</li>
<li>
<code>boolean tryAcquire()</code>, <code>boolean tryAcquire(int permits)</code>:
acquire permits only when they are available at the time of
invocation.
</li>
<li>
<code>boolean tryAcquire(long timeOut, TimeUnit unit)</code>
</li>
<li>
<code>void release()</code>, <code>void release(int permits)</code>
</li>
<li>
<code>void acquireUninterruptibly()</code>
</li>
<li>
<code>int drainPermits()</code>: accquire and return a count of all permits
that are immediately available.
</li>
<li>
</li>
</ul>
</li>
</ul>
</li>
<li>Phasers : is a more flexible cyclic barrier.
<ul class="org-ul">
<li>Is sueful when we have some concurrent tasks divided in steps. And
this class enable us to synchronize the threads at the end of each
steps.
<ul class="org-ul">
<li>so no thread starts its next step until all the threads
have finished the previous one.
</li>
</ul>
</li>
<li>Let a group of threads wait on a barrier; these threads continue
after the last thread arrives.
</li>
<li>Cyclic barrier coordinates a <b>fixed</b> number of threads, while a
phaser can coordiantes a <b>variable number</b> of threads, which can
register at any time.
</li>
<li>A <b>phase</b> is the phaser's <i>current state</i>, and this state is
identified by an integer-based <b>phase number</b>.
</li>
<li>
<code>Phaser(int nthreads)</code> : constructor creates a phaser that
initially coordiates <code>nthreads</code> threads, and whose <i>phase number</i> is
initially set to <code>0</code>.
</li>
<li>
<code>int register()</code> : add a new unarrived thread to this phaser and
returns the phase number to classify the arrival.
</li>
<li>
<code>int arriveAndAwaitAdvance()</code> : records arrival and <b>wait</b> for the
phaser to advance. Return the phase number to which the arrival
applies.
</li>
<li>
<code>int arriveAndDeregister()</code> : arrives at this phaser and
deregister from it without waiting for others to arrive, reducing
the number of threads required to avdance in future phases.
</li>
<li>TODO. need to have better understanding.
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">The Locking Framework</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li>
<code>synchronized</code> keyword is to wrap <b>critical sections</b>. JVM supports
synchronization via monitors and the <code>monitorenter</code> and
<code>monitorexit</code> JVM instructions.
<ul class="org-ul">
<li>Every Java object is associated with a monitor, which is <b>a mutual
exclusion</b> construct.
</li>
<li>When a thread locks a monitor in multicore/multiprocessor
environment, the value of shared variables that are stored in main
memory are read into the <b>local memory</b> or <b>cache memory</b> of the
thread.
</li>
<li>When a thread unlock the monitor while leaving the critical section,
the values in its copies are written back to main memory.
</li>
</ul>
</li>
<li>The more flexible <b>Lock</b> interface:
<ul class="org-ul">
<li>
<code>void lock()</code> : doesn't allow for interruption.
</li>
<li>
<code>void lockInterruptibly()</code> : allow for interruption.
</li>
<li>
<code>boolean tryLock()</code>, <code>boolean tryLock(long time, TimeUnit unit)</code> :
timeout, or interrupted.
</li>
<li>
<code>void unlock()</code>
</li>
</ul>
</li>
<li>
<b>ReentrantLock</b> class implements the <b>Lock</b> interface.
<ul class="org-ul">
<li>It is a reentrant mutual exclusion lock.
</li>
<li>This lock is associated with a hold count.
<ul class="org-ul">
<li>When a thread holds the lock and <b>reacquires</b> the lock, the hold
count increase by 1.
</li>
<li>When unlock from the thread, the hold count is decreased by 1.
</li>
<li>The lock is released when the count reaches 0.
</li>
<li>This is why it is called a <b>reentrant</b> lock.
</li>
</ul>
</li>
<li>ReentrantLock also support a fair ordering policy, by default
false.
</li>
<li>
<code>boolean isHeldByCurrentThread()</code> return true when the lock is
hold by the current thread.
</li>
</ul>
</li>
<li>
<b>Condition</b> interface factors out Object's wait and notification
methods into distinct condition objects.
<ul class="org-ul">
<li>
<code>await()</code> : wait to be signalled by the same condition.
<ul class="org-ul">
<li>The lock associated with this Condition is automatically
released and the current thread become disabled for thread
scheduling purpose and lies dormant until one of the following
four things happens:
<ul class="org-ul">
<li>
<code>signal()</code> called and the current thead happens to be chose to
be awaken.
</li>
<li>
<code>signalAll()</code> called.
</li>
<li>Is interrupted.
</li>
<li>A <i>spurious wakeup</i> occurs: this is why the await normally
need to be wrapped in while loop.
</li>
</ul>
</li>
<li>In all cases, before <code>await()</code> can return, the current thread
must <b>re-acquire</b> the lock associated with this condition. The
thread is guaranteed to hold this lock when the method return.
</li>
</ul>
</li>
<li>
<code>signal()</code>, <code>signalAll()</code>
</li>
<li>The two methods are protected with the lock to ensure mutual
exclusion.
</li>
<li>the <code>await()</code> is normally wrapped in a while loop on the checked
condition.
</li>
</ul>
</li>
<li>The Lock replaces synchronized methods, Condition replaces Object's
wait/notification methods.
</li>
<li>A Condition instance is intrinsically bound to a lock. To obtain a
Condition instance for a certain Lock instance, use the Lock's
<code>newCondition()</code> method.
</li>
<li>Multiple condition can be created from a Lock.
</li>
<li>Example:
<div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">BoundedBuffer</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">();</span>
    <span class="kd">final</span> <span class="n">Condition</span> <span class="n">notFull</span>  <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
    <span class="kd">final</span> <span class="n">Condition</span> <span class="n">notEmpty</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>

    <span class="kd">final</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">items</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="mi">100</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">putptr</span><span class="o">,</span> <span class="n">takeptr</span><span class="o">,</span> <span class="n">count</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">Object</span> <span class="n">x</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
	<span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
	<span class="k">try</span> <span class="o">{</span>
	    <span class="k">while</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">items</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
		<span class="n">notFull</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
	    <span class="n">items</span><span class="o">[</span><span class="n">putptr</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
	    <span class="k">if</span> <span class="o">(++</span><span class="n">putptr</span> <span class="o">==</span> <span class="n">items</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="n">putptr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	    <span class="o">++</span><span class="n">count</span><span class="o">;</span>
	    <span class="n">notEmpty</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
	<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
	    <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
	<span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">take</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
	<span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
	<span class="k">try</span> <span class="o">{</span>
	    <span class="k">while</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
		<span class="n">notEmpty</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
	    <span class="n">Object</span> <span class="n">x</span> <span class="o">=</span> <span class="n">items</span><span class="o">[</span><span class="n">takeptr</span><span class="o">];</span>
	    <span class="k">if</span> <span class="o">(++</span><span class="n">takeptr</span> <span class="o">==</span> <span class="n">items</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="n">takeptr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	    <span class="o">--</span><span class="n">count</span><span class="o">;</span>
	    <span class="n">notFull</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
	    <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
	<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
	    <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
	<span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</li>
<li>
<b>ReadWriteLock</b> interface defines a pair of locks: one for read-only
operations and one for write operations.
<ul class="org-ul">
<li>The read lock may be held simultaneously by multiple reader
threads as long as there are no writes.
</li>
<li>The write lock is exclusive: only a single thread can modify
shared data.
</li>
</ul>
</li>
<li>
<b>ReadWriteLock</b> is implemented by the <b>ReentrantReadWriteLock</b>
  class.
</li>
<li>
<b>StampedLock</b> is another implementation of <b>ReadWriteLock</b>. The main
differences are:
<ul class="org-ul">
<li>StampedLock allow optimistic locking for read operations.
</li>
<li>ReentrantReadWriteLock are reentrant while stampedlock are not.
</li>
<li>When the readers are much more than writers, the StampedLock can
significantly improve performance.
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">LockSupport</h3>
<div class="outline-text-3" id="text-1-7">
<ul class="org-ul">
<li>This class associates with each thread that uses it, <b>a permit</b> (in
the sense of the Semaphore class).
<ul class="org-ul">
<li>A call to <code>static void park()</code> return immediately if the permit is available,
consuming it in the process; otherwise it <b>may</b> block.
</li>
<li>A call to <code>static void unpark(Thread thread)</code>, if it was not
already available.
</li>
<li>
<code>park()</code> will return if the caller's thread was interrupted, and
timeout versions are supported
</li>
<li>The <code>park()</code> method may also return at any other time, for "<b>no
reason</b>", so in general must be invoked within a loop that
rechecks condition upon return.
</li>
<li>In this sense, <code>park</code> serves as an optimization of a <b>busy wait</b>
that doesn't waste as much time spining, but must be paired with
an <code>unpark</code> to be effective.
</li>
</ul>
</li>
<li>Unlike Semaphore's permits, permits of LockSupport are associated
with threads (i.e. permit is given to a particular thread) and
doesn't accumulate, i.e. there can be only one permit per thread,
when thread consumes the permit, it disappears).
</li>
<li>You can give permit to a thread by calling unpark(). When permit is
available, the parked thread consumes it and exits a park() method.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">Concurrent Collections</h3>
<div class="outline-text-3" id="text-1-8">
<ul class="org-ul">
<li>The concurrent collections return <b>weakly-consistent iterators</b>:
<ul class="org-ul">
<li>An elements that is removed after iteration starts but hasn't yet
been returned via the iterator's <code>next()</code> method <b>won't</b> be
returned.
</li>
<li>An element that's added after iteration starts <b>may or may not</b> be
returned.
</li>
<li>No element is returned more than once during the iteration of a
collection, regardless of changes made to the collection during
iteration.
</li>
</ul>
</li>
<li>
<b>BlockingQueue</b>'s implementation:
<ul class="org-ul">
<li>
<b>ArrayBlockingQueue</b>
</li>
<li>
<b>LinkedBlockingQueue</b>
</li>
<li>
<b>PriorityBlockingQueue</b>
</li>
<li>
<b>SynchronousQueue</b>
</li>
<li>
<b>DelayQueue</b>
</li>
<li>
<b>LinkedTransferQueue</b>
</li>
</ul>
</li>
<li>
<b>ConcurrentMap</b>'s additional methods:
<ul class="org-ul">
<li>
<code>V putIfAbsent(K key, V value)</code> : combines the <code>containsKey</code> and
<code>put</code> for a atomic operation.
</li>
<li>
<code>boolean remove(Object key, Object value)</code> : remove the entry for
a key only if currently mapped to a given value.
</li>
<li>
<code>boolean replace(K key, V oldValue, V newValue)</code>: replace the
entry for a key only if currently mapped to a given value.
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9">Atomic Variables</h3>
<div class="outline-text-3" id="text-1-9">
<ul class="org-ul">
<li>The atomic classes extends the notion of <code>volatile</code> values, fields,
and array elements to those that also provide an atomic conditional
update so that external synchronisation isn't required.
</li>
<li>The atomic arrays: <b>AtomicIntegerArray</b>, <b>AtomicLongArray</b> and
<b>AtomicReferenceArray</b>. Its elements may be updated atomically.
</li>
<li>For scalability problem in the context of maintaining a single
<b>count</b>, a <b>sum</b> or some other value with the possibility of updates
from many threads:
<ul class="org-ul">
<li>Internally employ contention-reduction techniques that provide
huge throughput improvements compared to atomic variables.
</li>
<li>
<b>DoubleAccumulator</b> and <b>LongAccumulator</b>: Take a BinaryOperator
</li>
<li>
<b>DoubleAdder</b> and <b>LongAdder</b>: provides analogy of the
functionality of the accumulators for the common special case of
maintaining counts and sums.
</li>
<li>
<code>new LongAdder()</code> is equivalent to <br><code>new LongAccumulator ((x+y)-&gt;x+y), 0l)</code>
</li>
</ul>
</li>
<li>Java's low-level synchronisation mechanism impacts hardware
utilisation and scalability in the following ways:
<ul class="org-ul">
<li>
<b>Contended synchronisation</b> where multiple threads constantly
competing for a lock, is expensive and throughput suffers as a result.
<ul class="org-ul">
<li>The expense is caused mainly by the frequent <b>context switching</b>.
</li>
<li>Each <b>context switch</b> operation can take many processor cycles to
complete.
</li>
<li>Modern JVM make <b>uncontended synchronisation</b> inexpensive.
</li>
</ul>
</li>
<li>When a thread holding a lock is delayed (because of a scheduling
delay for example), no thread that requires that lock makes any progress.
</li>
</ul>
</li>
<li>
<code>volatile</code> cannot be used as a synchronization alternative.
<ul class="org-ul">
<li>
<code>volatile</code> variables only solve the visibility problem.
</li>
<li>Cannot be used to safely implement the atomic <b>read-modify-write</b>
    sequence.
</li>
</ul>
</li>
<li>Compare-and-Swap(CAS) is an <b>uninterruptible</b> microprocessor specific
instruction that :
<ol class="org-ol">
<li>Read value with an expected value,
</li>
<li>Store a new value in the memory location if the read value matches
the expected value.
</li>
<li>Otherwise, nothing is done.
</li>
</ol>
</li>
<li>CAS supports atomic <b>read-modify-write</b> sequences:
<ol class="org-ol">
<li>Read value <code>x</code> from address <code>A</code>
</li>
<li>Perform a multistep computation on <code>x</code> to drive a new value <code>y</code>
</li>
<li>Use CAS to change ghe value of <code>A</code> from <code>x</code> to <code>y</code>.
</li>
<li>CAS succeeds when <code>A</code>'s value hasn't changed while performing
these steps.
</li>
<li>This is normally wrapped in a while loop to repeat until success.
</li>
</ol>
</li>
<li>
<b>ReentrantLock</b> offers better performance than <code>synchronized</code> under
high thread contention.
<ul class="org-ul">
<li>its synchronization is managed by a subclass of
<code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code>,
</li>
<li>which in turn, leverages the <code>sun.mics.Unsafe</code> class and its
<code>compareAndSwapInt()</code> CAS method.
</li>
</ul>
</li>
<li>The atomic variable classes also leverage CAS with a method:
<code>boolean compareAndSet(expectedValue, updateValue)</code>.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10">Fork/Join</h3>
<div class="outline-text-3" id="text-1-10">
<ul class="org-ul">
<li>Fork/Join consists of a special <b>executor service</b> and <b>thread
pool</b>:
<ul class="org-ul">
<li>The executor service makes a task available to the framework,
</li>
<li>And this task is broken into smaller tasks that are forked
(executed by different threads) from the pool.
</li>
<li>A task waits until joined (its subtasks finish).
</li>
</ul>
</li>
<li>TODO
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11">CompletionService</h3>
<div class="outline-text-3" id="text-1-11">
<ul class="org-ul">
<li>A service that decouples the production of new tasks from the
consumption of the tasks' results <b>in the order</b> they complete.
<ul class="org-ul">
<li>Producer <code>submit</code>
</li>
<li>Consumer <code>poll</code> or <code>take</code>
</li>
</ul>
</li>
<li>
<code>poll()</code> : Retrieves and removes the Future representing the next
completed task, or <code>null</code> if none are present.
</li>
<li>
<code>poll(long timeout, TimeUnit unit)</code>: waiting if necessary.
</li>
<li>
<code>take()</code> : block if none are yet present.
</li>
<li>Difference between executor service and completion service:
<ul class="org-ul">
<li>ExecutorService provides an incoming queue for tasks and provides
workers threads.
</li>
<li>CompletionService provides an incoming queue for tasks, worker
threads, <b>and</b> an output queue for storing task results.
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12">Testing Concurrent Applications</h3>
<div class="outline-text-3" id="text-1-12">
<ul class="org-ul">
<li>Monitoring <b>ReentrantLock</b> with its methods:
<ul class="org-ul">
<li>
<code>protected Thead getOwner()</code> : return the Thread that currently
owns this lock, or null if not owned.
<ul class="org-ul">
<li>Noticed that this is a protected method, so to use it one will
need to extend.
</li>
</ul>
</li>
<li>
<code>protected getQueuedThreads()</code> : return the collection containing
the threads that may be waiting to acquire this lock.
</li>
<li>
<code>protected getWaitingThreads(Condition condition)</code> : return the
collection containing the threads that may be waiting ont he given
condition associated with this lock.
</li>
<li>
<code>isHeldbycurrentthread()</code> queries if this lock is hold by the
current thread.
</li>
<li>
<code>isLocked()</code> : indicating if this lock is owned by a thread.
</li>
</ul>
</li>
<li>
<b>MultithreadedTC</b> is a library for testing concurrent application.
<ul class="org-ul">
<li>It features a <b>metronome/clock</b> that is used to provide <b>fine control</b>
    over <b>the sequence of activities</b> in multiple threads.
</li>
<li>It supports test cases that execise a <b>specific</b> interleaving of
the threads.
</li>
<li>It is motivited by the <b>principle</b> that <i>cuncurrent application
shoul be built using <b>small concurrent abstractions</b></i> such as
<i>bounded buffers</i>, <i>semaphores</i> and <i>latches</i>.
<ul class="org-ul">
<li>Separating the concurrency logic from the rest of the application
logic in this way makes it easier to understand and test
concurrent applications.
</li>
<li>Since these abstractions are small, it should be possible to
<b>deterministically</b> test every <b>significant</b> interleaving in
separate tests.
</li>
</ul>
</li>
<li>It uses an internal clock:
<ul class="org-ul">
<li>the clock only advances to the next tick when all threads are
blocked.
</li>
<li>waitForTick(1) : makes thread block until the clock reaches tick
1 before assuming. The interger received in this method is used
to control the order of execution.
</li>
<li>assertTick(1) : assert that the clock is in tick 1.
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../../categories/concurrency/" rel="tag">concurrency</a></li>
            <li><a class="tag p-category" href="../../../categories/java/" rel="tag">java</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../java-hotspot-gc/" rel="prev" title="Java HotSpot VM GC Tunning Guide">Previous post</a>
            </li>
            <li class="next">
                <a href="../java-8-topics/" rel="next" title="Java 8 Topics">Next post</a>
            </li>
        </ul></nav></aside></article><footer id="footer"><p>Contents © 2017         <a href="mailto:wudong@graceliu.uk">Warren Liu</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
            
        </footer>
</div>
    </div>
    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
    
    
    
            <script src="../../../assets/js/jquery.min.js"></script><script src="../../../assets/js/moment-with-locales.min.js"></script><script src="../../../assets/js/fancydates.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</body>
</html>
