<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Warren Liu (Posts about concurrency)</title><link>https://example.com/</link><description></description><atom:link href="https://example.com/categories/concurrency.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2017 &lt;a href="mailto:n.tesla@example.com"&gt;Warren Liu&lt;/a&gt; </copyright><lastBuildDate>Sat, 15 Jul 2017 11:32:22 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Java Concurrency</title><link>https://example.com/posts/notes/java-concurrency/</link><dc:creator>Warren Liu</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://example.com/posts/notes/java-concurrency/#sec-1"&gt;Java Thread/Concurrency&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://example.com/posts/notes/java-concurrency/#sec-1-1"&gt;Thread&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://example.com/posts/notes/java-concurrency/#sec-1-2"&gt;Synchronization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://example.com/posts/notes/java-concurrency/#sec-1-3"&gt;Waiting and Notification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://example.com/posts/notes/java-concurrency/#sec-1-4"&gt;Concurrency Utilities and Executors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://example.com/posts/notes/java-concurrency/#sec-1-5"&gt;Synchronizers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://example.com/posts/notes/java-concurrency/#sec-1-6"&gt;The Locking Framework&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://example.com/posts/notes/java-concurrency/#sec-1-7"&gt;LockSupport&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://example.com/posts/notes/java-concurrency/#sec-1-8"&gt;Concurrent Collections&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://example.com/posts/notes/java-concurrency/#sec-1-9"&gt;Atomic Variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://example.com/posts/notes/java-concurrency/#sec-1-10"&gt;Fork/Join&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://example.com/posts/notes/java-concurrency/#sec-1-11"&gt;CompletionService&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://example.com/posts/notes/java-concurrency/#sec-1-12"&gt;Testing Concurrent Applications&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Java Thread/Concurrency&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;/div&gt;&lt;div id="outline-container-sec-1-1" class="outline-3"&gt;
&lt;h3 id="sec-1-1"&gt;Thread&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-1"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Thread's &lt;b&gt;Execution State&lt;/b&gt; with the &lt;code&gt;Thread.getState()&lt;/code&gt; method
returns &lt;code&gt;Enum Thread.State&lt;/code&gt;:
&lt;dl class="org-dl"&gt;
&lt;dt&gt; NEW &lt;/dt&gt;&lt;dd&gt;not yet started
&lt;/dd&gt;
&lt;dt&gt; RUNNABLE &lt;/dt&gt;&lt;dd&gt;executing
&lt;/dd&gt;
&lt;dt&gt; BLOCKED &lt;/dt&gt;&lt;dd&gt;A thread that is blocked &lt;b&gt;waiting for a monitor locks&lt;/b&gt;
&lt;/dd&gt;
&lt;dt&gt; WAITING &lt;/dt&gt;&lt;dd&gt;waiting &lt;b&gt;indefinitely&lt;/b&gt; for another thread to perform a
particular action. A thread is in this state due to
calling one of the following methods:
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;Object.wait()&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Thread.join()&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LockSupport.park()&lt;/code&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;dt&gt; TIMED&lt;sub&gt;WAITING&lt;/sub&gt; &lt;/dt&gt;&lt;dd&gt;waiting with a specified waiting time.
&lt;ul class="org-ul"&gt;
&lt;li&gt;Apart from the timeout version of the above methods,
&lt;code&gt;Thread.sleep()&lt;/code&gt; also put thread into this state.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;dt&gt; TERMINATED &lt;/dt&gt;&lt;dd&gt;exited
&lt;/dd&gt;
&lt;dt&gt; (no term) &lt;/dt&gt;&lt;dd&gt;Notice the difference between &lt;b&gt;BLOCKED&lt;/b&gt; and &lt;b&gt;WAITING&lt;/b&gt;.
&lt;/dd&gt;
&lt;dt&gt; (no term) &lt;/dt&gt;&lt;dd&gt;Differenct WAITING status:
&lt;ul class="org-ul"&gt;
&lt;li&gt;STATE: &lt;b&gt;BLOCKED (on object monitor)&lt;/b&gt; : waiting for monitor entry,
when using intrinsicLock, i.e., the &lt;code&gt;synchronized&lt;/code&gt; keyword.
&lt;/li&gt;
&lt;li&gt;STATE: &lt;b&gt;WAITING (parking)&lt;/b&gt;: waiting on condition, when using locks
from &lt;code&gt;java.util.concurrent&lt;/code&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;

&lt;li&gt;Thread's priority is taken into consideration by OS's Scheduler.
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;void setPriority(int priority)&lt;/code&gt; : take value between
&lt;b&gt;Thread.MIN&lt;sub&gt;PRIORITY&lt;/sub&gt;&lt;/b&gt; and &lt;b&gt;Thread.MAX&lt;sub&gt;PRIORITY&lt;/sub&gt;&lt;/b&gt;, and
Thread.NORMAL&lt;sub&gt;PRIORITY&lt;/sub&gt;* identifies the default priority.
&lt;/li&gt;
&lt;li&gt;On Linux, the default scheduler is &lt;b&gt;Completely Fair Scheduler&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;References:
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Completely_Fair_Scheduler"&gt;https://en.wikipedia.org/wiki/Completely_Fair_Scheduler&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.informit.com/articles/article.aspx?p=101760"&gt;http://www.informit.com/articles/article.aspx?p=101760&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.linuxjournal.com/magazine/completely-fair-scheduler"&gt;http://www.linuxjournal.com/magazine/completely-fair-scheduler&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Use a &lt;b&gt;red-black tree&lt;/b&gt; (self balanced binary tree) to sort process
according to its &lt;b&gt;execution time&lt;/b&gt;.
&lt;/li&gt;
&lt;li&gt;Process with lowest execution time is scheduled next to run.
&lt;/li&gt;
&lt;li&gt;Process running exceeding the max execution time is reinserted
into the tree for further scheduling.
&lt;/li&gt;
&lt;li&gt;If a process spends a lot of its time sleeping, then its spent
time value is low and it automatically gets the priority boost
when it finally needs it
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;On Windows, it is &lt;b&gt;multilevel feedback queue scheduler&lt;/b&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A &lt;b&gt;daemon thread&lt;/b&gt; is a thread that acts as a helper to &lt;b&gt;nondaemon
thread&lt;/b&gt; and &lt;b&gt;dies&lt;/b&gt; automatically when the application's last
nondaemon thread dies so that the application can terminate.
&lt;/li&gt;
&lt;li&gt;Application will not terminate when the nondaemon default main
thread terminates until all background nondaemon threads
terminate.
&lt;/li&gt;
&lt;li&gt;Interrupting Threads
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;void interrupt()&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;If this thread is &lt;b&gt;blocked&lt;/b&gt; because a call to &lt;code&gt;wait()&lt;/code&gt;, &lt;code&gt;sleep()&lt;/code&gt;
or &lt;code&gt;join()&lt;/code&gt; methods, the thread's &lt;b&gt;interrupted status&lt;/b&gt; is
cleared and &lt;b&gt;InterruptedException&lt;/b&gt; is thrown.
&lt;/li&gt;
&lt;li&gt;If this thread is &lt;b&gt;blocked&lt;/b&gt; in an I/O operation on an
&lt;b&gt;interruptible channel&lt;/b&gt;, the channel will be closed, the
interrupt status will be set and the thread will receive a
&lt;b&gt;ClosedByInterruptException&lt;/b&gt;.
&lt;/li&gt;
&lt;li&gt;If the thread is blocked in a &lt;b&gt;Selector&lt;/b&gt;, then the interrupt
status will be set and it will return immediately from the
selection operation. possilby with a non-zero value.
&lt;/li&gt;
&lt;li&gt;Otherwise the interrupt status is set.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static boolean interrupted()&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Test whether the &lt;b&gt;current&lt;/b&gt; thread has been interrupted. The
interrupted status of the thread is cleard by this method.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean isInterrupted()&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Test whether this thread has been interrupted. The interrupted
status of the thread is unaffected by this method.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Joining Threads:
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;void join()&lt;/code&gt; : The calling/current* thread will wait for &lt;b&gt;this&lt;/b&gt;
thread to die. &lt;b&gt;InterruptedException&lt;/b&gt; is thrown when any thread
interrupted the &lt;b&gt;current&lt;/b&gt; thread.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void join(long millis), void join(long millis, int nanos)&lt;/code&gt; :
passing &lt;code&gt;0&lt;/code&gt; to wait indefinitely.
&lt;/li&gt;
&lt;li&gt;This implementation uses a loop of &lt;code&gt;this.wait&lt;/code&gt; calls conditioned
on &lt;code&gt;this.isAlive&lt;/code&gt;. As a thread terminates the &lt;code&gt;this.notifyAll&lt;/code&gt;
method is invoked.
&lt;/li&gt;
&lt;li&gt;&lt;span class="underline"&gt;It is recommended that &lt;b&gt;applications&lt;/b&gt; not use &lt;code&gt;wait&lt;/code&gt;, &lt;code&gt;notify&lt;/code&gt;, or
&lt;code&gt;notifyAll&lt;/code&gt; on Thread instances&lt;/span&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Thread.UncaughtExceptionHandler&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;A Thread can set a handler when this thread abruptly terminates
due to an uncaught exception.
&lt;/li&gt;
&lt;li&gt;If the thread has not set a handler, its ThreadGroup (which
implements the Handler interface) acts as its handler.
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;static void setDefaultUncaughtExceptionHandler()&lt;/b&gt; to set a global
default handler for all thread and will be called when the thread
has no handler set, and when its thread group (including parent
thread groups) does not specialize its &lt;code&gt;uncaughtException&lt;/code&gt; method.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;ThreadGroup&lt;/b&gt; can forms a tree like structure.
&lt;/li&gt;
&lt;li&gt;Values stored in &lt;b&gt;thread-local&lt;/b&gt; variables are not related.
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;InheritableThreadLocal&lt;/b&gt; : When a child thread is created, the child
receives &lt;b&gt;initial values&lt;/b&gt; for all &lt;b&gt;inheritable thread-local
variables&lt;/b&gt; for which the parent has values.
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;protected T childValue(T parentValue)&lt;/code&gt;: method used to calculate the
child's initial value as a function of the parent's value at the
time the child thread is created. This is called from within the
parent thread before the child is started.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;java.util.Timer&lt;/b&gt; and &lt;b&gt;java.util.TimerTask&lt;/b&gt; for simple job scheduler
&lt;ul class="org-ul"&gt;
&lt;li&gt;Timer let you schedule TimerTask for future execution on a
background thread, which is known as the &lt;i&gt;task-execution thread&lt;/i&gt;.
&lt;/li&gt;
&lt;li&gt;Timer tasks may be scheduled for one-shot execution, or for
repeated execution at regular intervals.
&lt;/li&gt;
&lt;li&gt;Timer scales to large numbers of concurrently scheduled timer
tasks. &lt;i&gt;Thousands of tasks should present no problem&lt;/i&gt;.
&lt;/li&gt;
&lt;li&gt;Timer can be set as a daemon which will make the &lt;i&gt;task-execution
thread&lt;/i&gt; a daemon task.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-2" class="outline-3"&gt;
&lt;h3 id="sec-1-2"&gt;Synchronization&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-2"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;counter++&lt;/code&gt; : although a it might look like a single operation, it
is actually three separate operations: read, add 1 and write. It is
not thread safe.
&lt;/li&gt;
&lt;li&gt;The compiler, the Java virtual machine (JVM), and the operating
system can collaborate to cache a variable in a register or a
processor-local cacherather than rely on main memory.
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;Each thread&lt;/b&gt; has its &lt;b&gt;own copy&lt;/b&gt; of the variable.
&lt;/li&gt;
&lt;li&gt;When one thread writes to this variable, it’s writing to its copy;
&lt;/li&gt;
&lt;li&gt;Other threads are unlikely to see the update in their copies.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Synchronization properties:
&lt;dl class="org-dl"&gt;
&lt;dt&gt; mutual exclusion &lt;/dt&gt;&lt;dd&gt;each thread is mutually excluded from
executing in critical section when another thread is inside the
critical section.
&lt;ul class="org-ul"&gt;
&lt;li&gt;the lock is often referred to as &lt;b&gt;mutex lock&lt;/b&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;dt&gt; property of visibility &lt;/dt&gt;&lt;dd&gt;ensures that a thread executing in a
critical section always sees the most recent changes to shared variables.
&lt;ul class="org-ul"&gt;
&lt;li&gt;It reads these variable from main memory on entry and writes
values to main memory on exit.
&lt;/li&gt;
&lt;li&gt;In practical terms, on current hardware, this typically causes
flushing of the CPU caches when a monitor is acquired and writes
to main memory when it is released, both of which are expensive.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;Synchronisation is implemented using monitors. Each Java object is
associated with a monitor, which a thread can &lt;b&gt;lock&lt;/b&gt; or &lt;b&gt;unlock&lt;/b&gt;
by acquiring and releasing the monitor's lock (a token).
&lt;/li&gt;
&lt;li&gt;When a thread attempts to acquire a lock that it already holds, the
request succeeds.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.lang.Thread&lt;/code&gt; has a &lt;code&gt;static boolean holdsLock(Object o)&lt;/code&gt; method
that returns &lt;code&gt;true&lt;/code&gt; when the calling thread holds the lock on the
Object.
&lt;/li&gt;
&lt;li&gt;A thread that has acquired a lock &lt;b&gt;doesn't&lt;/b&gt; release this lock when
it calls one of the Thread's &lt;code&gt;sleep()&lt;/code&gt; methods.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt; exhibits the property of &lt;b&gt;visibility&lt;/b&gt;.
&lt;ul class="org-ul"&gt;
&lt;li&gt;Using volatile, forces all accesses (read or write) to the
volatile variable to occur to main memory, effectively keeping the
volatile variable out of CPU caches.
&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;volatile&lt;/code&gt; only when visibility is an issue.
&lt;/li&gt;
&lt;li&gt;Only &lt;b&gt;field&lt;/b&gt; can be declared as volatile, not on local variable.
&lt;/li&gt;
&lt;li&gt;You can declare &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt; fields to be &lt;code&gt;volatile&lt;/code&gt;, but
should avoid on &lt;b&gt;32-bit&lt;/b&gt; JVMs because it takes two operations to
access a &lt;code&gt;double&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; value.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt; field cannot also be declared &lt;code&gt;final&lt;/code&gt;. But this isn't a
problem because &lt;code&gt;final&lt;/code&gt; field can be safely accessed without
synchronization.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt; along can be thread unsafe if the operation involve the
volatile variable has multiple step. For example:
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;check-then-act&lt;/b&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;read-modify-write&lt;/b&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/3519664/difference-between-volatile-and-synchronized-in-java"&gt;http://stackoverflow.com/questions/3519664/difference-between-volatile-and-synchronized-in-java&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-3" class="outline-3"&gt;
&lt;h3 id="sec-1-3"&gt;Waiting and Notification&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-3"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;The &lt;code&gt;wait/notify&lt;/code&gt; enables one thread waits for a &lt;b&gt;condition&lt;/b&gt; to
exist. And another thread to create the condition and then notify
the waiting thread.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void wait()&lt;/code&gt;: cause the current thread to wait until another thread
invokes the &lt;code&gt;notify()&lt;/code&gt; or &lt;code&gt;notifyAll()&lt;/code&gt;, or for some other thread to
interrupt the current thread while waiting.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void notify()&lt;/code&gt;: Wake up a &lt;b&gt;single&lt;/b&gt; thread that's waiting on this
object's monitor.
&lt;ul class="org-ul"&gt;
&lt;li&gt;If more than one threads are waiting on this object,
one(arbitrary) of them is chosen.
&lt;/li&gt;
&lt;li&gt;The awakened thread will not be able to proceed until the current
thread relinquishes the lock on this object.
&lt;/li&gt;
&lt;li&gt;A thread releases ownership of the monitor associated with the
object whose &lt;code&gt;wait()&lt;/code&gt; method is called.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;This API leverages an object's &lt;b&gt;condition queue&lt;/b&gt;, which is a
data structure that stores threads waiting for a condition to exists.
&lt;ul class="org-ul"&gt;
&lt;li&gt;The waiting threads are known as the &lt;b&gt;wait set&lt;/b&gt;.
&lt;/li&gt;
&lt;li&gt;Because the condition queue is tightly bound to an object's lock,
all methods in this API must be called from within a synchronized
context. The current thread must be the owner of the object's
monitor.
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;synchronized&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;(&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="n"&gt;does&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;hold&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
	&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;wait&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;//perform an action that's appropriate to condition.&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Because of the possibility of &lt;b&gt;spurious wakeups&lt;/b&gt;, a thread might
wakes up without being notified, interrupted, or timingout),
&lt;code&gt;wait()&lt;/code&gt; is called from within the &lt;code&gt;while&lt;/code&gt; loop.
&lt;/li&gt;
&lt;li&gt;Never call a &lt;code&gt;wait()&lt;/code&gt; outside a loop.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Otherwise &lt;b&gt;java.lang.IllegalMonitorStateException&lt;/b&gt; is thrown.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In &lt;b&gt;java.util.concurrent.locks.Condition&lt;/b&gt;, it factors out these
Object's monitor methods into distinct objects to give the effect of
having multiple &lt;b&gt;wait-sets&lt;/b&gt; per object, by combining them with the
use of arbitrary &lt;b&gt;Lock&lt;/b&gt; implementations.
&lt;/li&gt;
&lt;li&gt;Where a &lt;b&gt;Lock&lt;/b&gt; replaces the use of &lt;code&gt;synchronized&lt;/code&gt; methods and
statements, a &lt;b&gt;Condition&lt;/b&gt; replaces the use of the Object monitor
methods.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-4" class="outline-3"&gt;
&lt;h3 id="sec-1-4"&gt;Concurrency Utilities and Executors&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-4"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;The &lt;b&gt;ExecutorService&lt;/b&gt; extends &lt;b&gt;Executor&lt;/b&gt;, is typically implemented
by a thread pool.
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;invokeAll&lt;/code&gt;, &lt;code&gt;invokeAny&lt;/code&gt; perform the bulk execution, executing a
collection of tasks and then waiting for at least one, or all, to
complete.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;CompletionService&lt;/b&gt; interface and its implementation
&lt;b&gt;ExecutorCompletionService&lt;/b&gt;, arranges that submitted tasks are, upon
completion, placed on a queue accessible using
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;take()&lt;/code&gt;: which will block until a result is available.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;poll()&lt;/code&gt;: which will return &lt;code&gt;null&lt;/code&gt; if no result is available.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-5" class="outline-3"&gt;
&lt;h3 id="sec-1-5"&gt;Synchronizers&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-5"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Countdown Latches : causes one or more threads to wait at a &lt;i&gt;gate&lt;/i&gt;
until another thread open this gate, at which point these other
threads can continue.
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;void await(), void await(long timeout, TimeUnit unit)&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void countDown()&lt;/code&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cyclic Barriers : lets a set of threads wait for each other to reach
a common barrier point.
&lt;ul class="org-ul"&gt;
&lt;li&gt;Useful in &lt;b&gt;parallel decomposition&lt;/b&gt; scenarios, where a lengthy task
is divided into subtasks whose individual results are later merged
into the overall result of the task.
&lt;/li&gt;
&lt;li&gt;The barrier is &lt;i&gt;cyclic&lt;/i&gt; because it can be reused after the waiting
threads are released.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CyclicBarrier(int parties)&lt;/code&gt; : specific number of parties( threads
working toward a common goal)
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CyclicBarrier(int parties, Runnable barrierAction)&lt;/code&gt; : the
barrierAction is executed when the barrier is &lt;i&gt;tripped&lt;/i&gt;.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int await(), int ~await(long timeout, TimeUnit unit)&lt;/code&gt; : force
the calling thread to wait until all parties have invoked
&lt;code&gt;await()&lt;/code&gt; on this cyclic barrier.
&lt;ul class="org-ul"&gt;
&lt;li&gt;the method return the arrival index of the calling thread, where
a index  &lt;code&gt;getParties() -1&lt;/code&gt; indicates the first thread to arrive,
and &lt;code&gt;zero&lt;/code&gt; indicates the last thread to arrive (countdown).
&lt;/li&gt;
&lt;li&gt;The calling thread will &lt;b&gt;also stop waiting&lt;/b&gt; when it, or &lt;b&gt;another
waiting thread&lt;/b&gt; is interrupted, timeout, or &lt;code&gt;reset()&lt;/code&gt; is called
on this cyclic barrier.
&lt;/li&gt;
&lt;li&gt;If the calling thread on wait is interrupted, this thread will
throw &lt;b&gt;InterruptedException&lt;/b&gt;, while other waiting thread will
throw &lt;b&gt;BrokenBarrierException&lt;/b&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean isBroken()&lt;/code&gt; : return &lt;code&gt;true&lt;/code&gt; when one or more parties
broke out of this barrier because of interruption or timeout
since the cyclic barrier was constructed, or last reset.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void reset()&lt;/code&gt; : reset the barrier to its initial state. If any
parties are currently waiting at the barrier, they will return
with a &lt;b&gt;BrokenBarrierException&lt;/b&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Exchangers :provides a synchronization point where threads can swap
objects.
&lt;ul class="org-ul"&gt;
&lt;li&gt;Each thread presents some boject on entry to the exchanger's
&lt;code&gt;exchange()&lt;/code&gt; method, matches with a partner thread, and receives
its partner's object on return.
&lt;/li&gt;
&lt;li&gt;Useful in applications such as genetic algorithms and pipeline
design.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.util.concurrent.Exchanger&amp;lt;V&amp;gt;&lt;/code&gt; has &lt;code&gt;V exchange(V x)&lt;/code&gt; method:
wait for another thread to arrive at this exchange point and then
transfer the given object to it, receiving the other thread's
object in return.
&lt;ul class="org-ul"&gt;
&lt;li&gt;If another thread is already waiting at the exchange point:
&lt;ul class="org-ul"&gt;
&lt;li&gt;It is resumed for thread-scheduling purposes and receives the
object passed in by the calling thread.
&lt;/li&gt;
&lt;li&gt;The current threads return immediately.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Semaphores : maintains a set of &lt;b&gt;permits&lt;/b&gt; for restricting the member
of threads that can access a limited resource.
&lt;ul class="org-ul"&gt;
&lt;li&gt;A thread attempting to acquire a permit when no permits are
available blocks until some other thread releases a permit.
&lt;/li&gt;
&lt;li&gt;Semaphores whose values can be more than 1 are known as &lt;b&gt;counting
semaphores&lt;/b&gt;
&lt;/li&gt;
&lt;li&gt;Semaphores whoese value can be only 0 or 1 are known as &lt;b&gt;binary
semaphores&lt;/b&gt;, or &lt;b&gt;mutexes&lt;/b&gt;.
&lt;/li&gt;
&lt;li&gt;Semaphore can set to be fair (fairness policy) :
&lt;ul class="org-ul"&gt;
&lt;li&gt;when &lt;code&gt;false&lt;/code&gt;, i.e., not fair, it makes no guarantees about the
order in which threads acquire permites.
&lt;/li&gt;
&lt;li&gt;when &lt;code&gt;true&lt;/code&gt;, it guarantees the order as in FIFO, i.e., the first
thread invoking &lt;code&gt;acquire()&lt;/code&gt; will get the permit first.
&lt;/li&gt;
&lt;li&gt;Generally, semaphores used to control resource access should be
initialized as fair (&lt;b&gt;by default, it is not&lt;/b&gt;) to ensure that no
therad is starved out from accessing a resource.
&lt;/li&gt;
&lt;li&gt;When using semaphores for other kinds of synchronization
control, the throughput advantages of unfair ordering often
outweight fairness considerations.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void acquire()&lt;/code&gt;, &lt;code&gt;void acquire(int permits)&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean tryAcquire()&lt;/code&gt;, &lt;code&gt;boolean tryAcquire(int permits)&lt;/code&gt;:
acquire permits only when they are available at the time of
invocation.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean tryAcquire(long timeOut, TimeUnit unit)&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void release()&lt;/code&gt;, &lt;code&gt;void release(int permits)&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void acquireUninterruptibly()&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int drainPermits()&lt;/code&gt;: accquire and return a count of all permits
that are immediately available.
&lt;/li&gt;
&lt;li&gt;
&lt;/li&gt;&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Phasers : is a more flexible cyclic barrier.
&lt;ul class="org-ul"&gt;
&lt;li&gt;Is sueful when we have some concurrent tasks divided in steps. And
this class enable us to synchronize the threads at the end of each
steps.
&lt;ul class="org-ul"&gt;
&lt;li&gt;so no thread starts its next step until all the threads
have finished the previous one.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Let a group of threads wait on a barrier; these threads continue
after the last thread arrives.
&lt;/li&gt;
&lt;li&gt;Cyclic barrier coordinates a &lt;b&gt;fixed&lt;/b&gt; number of threads, while a
phaser can coordiantes a &lt;b&gt;variable number&lt;/b&gt; of threads, which can
register at any time.
&lt;/li&gt;
&lt;li&gt;A &lt;b&gt;phase&lt;/b&gt; is the phaser's &lt;i&gt;current state&lt;/i&gt;, and this state is
identified by an integer-based &lt;b&gt;phase number&lt;/b&gt;.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Phaser(int nthreads)&lt;/code&gt; : constructor creates a phaser that
initially coordiates &lt;code&gt;nthreads&lt;/code&gt; threads, and whose &lt;i&gt;phase number&lt;/i&gt; is
initially set to &lt;code&gt;0&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int register()&lt;/code&gt; : add a new unarrived thread to this phaser and
returns the phase number to classify the arrival.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int arriveAndAwaitAdvance()&lt;/code&gt; : records arrival and &lt;b&gt;wait&lt;/b&gt; for the
phaser to advance. Return the phase number to which the arrival
applies.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int arriveAndDeregister()&lt;/code&gt; : arrives at this phaser and
deregister from it without waiting for others to arrive, reducing
the number of threads required to avdance in future phases.
&lt;/li&gt;
&lt;li&gt;TODO. need to have better understanding.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-6" class="outline-3"&gt;
&lt;h3 id="sec-1-6"&gt;The Locking Framework&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-6"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;synchronized&lt;/code&gt; keyword is to wrap &lt;b&gt;critical sections&lt;/b&gt;. JVM supports
synchronization via monitors and the &lt;code&gt;monitorenter&lt;/code&gt; and
&lt;code&gt;monitorexit&lt;/code&gt; JVM instructions.
&lt;ul class="org-ul"&gt;
&lt;li&gt;Every Java object is associated with a monitor, which is &lt;b&gt;a mutual
exclusion&lt;/b&gt; construct.
&lt;/li&gt;
&lt;li&gt;When a thread locks a monitor in multicore/multiprocessor
environment, the value of shared variables that are stored in main
memory are read into the &lt;b&gt;local memory&lt;/b&gt; or &lt;b&gt;cache memory&lt;/b&gt; of the
thread.
&lt;/li&gt;
&lt;li&gt;When a thread unlock the monitor while leaving the critical section,
the values in its copies are written back to main memory.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The more flexible &lt;b&gt;Lock&lt;/b&gt; interface:
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;void lock()&lt;/code&gt; : doesn't allow for interruption.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void lockInterruptibly()&lt;/code&gt; : allow for interruption.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean tryLock()&lt;/code&gt;, &lt;code&gt;boolean tryLock(long time, TimeUnit unit)&lt;/code&gt; :
timeout, or interrupted.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void unlock()&lt;/code&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;ReentrantLock&lt;/b&gt; class implements the &lt;b&gt;Lock&lt;/b&gt; interface.
&lt;ul class="org-ul"&gt;
&lt;li&gt;It is a reentrant mutual exclusion lock.
&lt;/li&gt;
&lt;li&gt;This lock is associated with a hold count.
&lt;ul class="org-ul"&gt;
&lt;li&gt;When a thread holds the lock and &lt;b&gt;reacquires&lt;/b&gt; the lock, the hold
count increase by 1.
&lt;/li&gt;
&lt;li&gt;When unlock from the thread, the hold count is decreased by 1.
&lt;/li&gt;
&lt;li&gt;The lock is released when the count reaches 0.
&lt;/li&gt;
&lt;li&gt;This is why it is called a &lt;b&gt;reentrant&lt;/b&gt; lock.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ReentrantLock also support a fair ordering policy, by default
false.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean isHeldByCurrentThread()&lt;/code&gt; return true when the lock is
hold by the current thread.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Condition&lt;/b&gt; interface factors out Object's wait and notification
methods into distinct condition objects.
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;await()&lt;/code&gt; : wait to be signalled by the same condition.
&lt;ul class="org-ul"&gt;
&lt;li&gt;The lock associated with this Condition is automatically
released and the current thread become disabled for thread
scheduling purpose and lies dormant until one of the following
four things happens:
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;signal()&lt;/code&gt; called and the current thead happens to be chose to
be awaken.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;signalAll()&lt;/code&gt; called.
&lt;/li&gt;
&lt;li&gt;Is interrupted.
&lt;/li&gt;
&lt;li&gt;A &lt;i&gt;spurious wakeup&lt;/i&gt; occurs: this is why the await normally
need to be wrapped in while loop.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In all cases, before &lt;code&gt;await()&lt;/code&gt; can return, the current thread
must &lt;b&gt;re-acquire&lt;/b&gt; the lock associated with this condition. The
thread is guaranteed to hold this lock when the method return.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;signal()&lt;/code&gt;, &lt;code&gt;signalAll()&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;The two methods are protected with the lock to ensure mutual
exclusion.
&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;await()&lt;/code&gt; is normally wrapped in a while loop on the checked
condition.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The Lock replaces synchronized methods, Condition replaces Object's
wait/notification methods.
&lt;/li&gt;
&lt;li&gt;A Condition instance is intrinsically bound to a lock. To obtain a
Condition instance for a certain Lock instance, use the Lock's
&lt;code&gt;newCondition()&lt;/code&gt; method.
&lt;/li&gt;
&lt;li&gt;Multiple condition can be created from a Lock.
&lt;/li&gt;
&lt;li&gt;Example:
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BoundedBuffer&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="n"&gt;Lock&lt;/span&gt; &lt;span class="n"&gt;lock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ReentrantLock&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="n"&gt;Condition&lt;/span&gt; &lt;span class="n"&gt;notFull&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;newCondition&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="n"&gt;Condition&lt;/span&gt; &lt;span class="n"&gt;notEmpty&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;newCondition&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;items&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;putptr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;takeptr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
	&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;lock&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
	&lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
	    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;length&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
		&lt;span class="n"&gt;notFull&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;await&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
	    &lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;putptr&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
	    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(++&lt;/span&gt;&lt;span class="n"&gt;putptr&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;length&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;putptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
	    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
	    &lt;span class="n"&gt;notEmpty&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
	&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;finally&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
	    &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;unlock&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
	&lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="nf"&gt;take&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
	&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;lock&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
	&lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
	    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
		&lt;span class="n"&gt;notEmpty&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;await&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
	    &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;takeptr&lt;/span&gt;&lt;span class="o"&gt;];&lt;/span&gt;
	    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(++&lt;/span&gt;&lt;span class="n"&gt;takeptr&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;length&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;takeptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
	    &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
	    &lt;span class="n"&gt;notFull&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
	    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
	&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;finally&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
	    &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;unlock&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
	&lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;ReadWriteLock&lt;/b&gt; interface defines a pair of locks: one for read-only
operations and one for write operations.
&lt;ul class="org-ul"&gt;
&lt;li&gt;The read lock may be held simultaneously by multiple reader
threads as long as there are no writes.
&lt;/li&gt;
&lt;li&gt;The write lock is exclusive: only a single thread can modify
shared data.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;ReadWriteLock&lt;/b&gt; is implemented by the &lt;b&gt;ReentrantReadWriteLock&lt;/b&gt;
  class.
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;StampedLock&lt;/b&gt; is another implementation of &lt;b&gt;ReadWriteLock&lt;/b&gt;. The main
differences are:
&lt;ul class="org-ul"&gt;
&lt;li&gt;StampedLock allow optimistic locking for read operations.
&lt;/li&gt;
&lt;li&gt;ReentrantReadWriteLock are reentrant while stampedlock are not.
&lt;/li&gt;
&lt;li&gt;When the readers are much more than writers, the StampedLock can
significantly improve performance.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-7" class="outline-3"&gt;
&lt;h3 id="sec-1-7"&gt;LockSupport&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-7"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;This class associates with each thread that uses it, &lt;b&gt;a permit&lt;/b&gt; (in
the sense of the Semaphore class).
&lt;ul class="org-ul"&gt;
&lt;li&gt;A call to &lt;code&gt;static void park()&lt;/code&gt; return immediately if the permit is available,
consuming it in the process; otherwise it &lt;b&gt;may&lt;/b&gt; block.
&lt;/li&gt;
&lt;li&gt;A call to &lt;code&gt;static void unpark(Thread thread)&lt;/code&gt;, if it was not
already available.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;park()&lt;/code&gt; will return if the caller's thread was interrupted, and
timeout versions are supported
&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;park()&lt;/code&gt; method may also return at any other time, for "&lt;b&gt;no
reason&lt;/b&gt;", so in general must be invoked within a loop that
rechecks condition upon return.
&lt;/li&gt;
&lt;li&gt;In this sense, &lt;code&gt;park&lt;/code&gt; serves as an optimization of a &lt;b&gt;busy wait&lt;/b&gt;
that doesn't waste as much time spining, but must be paired with
an &lt;code&gt;unpark&lt;/code&gt; to be effective.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Unlike Semaphore's permits, permits of LockSupport are associated
with threads (i.e. permit is given to a particular thread) and
doesn't accumulate, i.e. there can be only one permit per thread,
when thread consumes the permit, it disappears).
&lt;/li&gt;
&lt;li&gt;You can give permit to a thread by calling unpark(). When permit is
available, the parked thread consumes it and exits a park() method.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-8" class="outline-3"&gt;
&lt;h3 id="sec-1-8"&gt;Concurrent Collections&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-8"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;The concurrent collections return &lt;b&gt;weakly-consistent iterators&lt;/b&gt;:
&lt;ul class="org-ul"&gt;
&lt;li&gt;An elements that is removed after iteration starts but hasn't yet
been returned via the iterator's &lt;code&gt;next()&lt;/code&gt; method &lt;b&gt;won't&lt;/b&gt; be
returned.
&lt;/li&gt;
&lt;li&gt;An element that's added after iteration starts &lt;b&gt;may or may not&lt;/b&gt; be
returned.
&lt;/li&gt;
&lt;li&gt;No element is returned more than once during the iteration of a
collection, regardless of changes made to the collection during
iteration.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;BlockingQueue&lt;/b&gt;'s implementation:
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;ArrayBlockingQueue&lt;/b&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;LinkedBlockingQueue&lt;/b&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;PriorityBlockingQueue&lt;/b&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;SynchronousQueue&lt;/b&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;DelayQueue&lt;/b&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;LinkedTransferQueue&lt;/b&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;ConcurrentMap&lt;/b&gt;'s additional methods:
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;V putIfAbsent(K key, V value)&lt;/code&gt; : combines the &lt;code&gt;containsKey&lt;/code&gt; and
&lt;code&gt;put&lt;/code&gt; for a atomic operation.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean remove(Object key, Object value)&lt;/code&gt; : remove the entry for
a key only if currently mapped to a given value.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean replace(K key, V oldValue, V newValue)&lt;/code&gt;: replace the
entry for a key only if currently mapped to a given value.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-9" class="outline-3"&gt;
&lt;h3 id="sec-1-9"&gt;Atomic Variables&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-9"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;The atomic classes extends the notion of &lt;code&gt;volatile&lt;/code&gt; values, fields,
and array elements to those that also provide an atomic conditional
update so that external synchronisation isn't required.
&lt;/li&gt;
&lt;li&gt;The atomic arrays: &lt;b&gt;AtomicIntegerArray&lt;/b&gt;, &lt;b&gt;AtomicLongArray&lt;/b&gt; and
&lt;b&gt;AtomicReferenceArray&lt;/b&gt;. Its elements may be updated atomically.
&lt;/li&gt;
&lt;li&gt;For scalability problem in the context of maintaining a single
&lt;b&gt;count&lt;/b&gt;, a &lt;b&gt;sum&lt;/b&gt; or some other value with the possibility of updates
from many threads:
&lt;ul class="org-ul"&gt;
&lt;li&gt;Internally employ contention-reduction techniques that provide
huge throughput improvements compared to atomic variables.
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;DoubleAccumulator&lt;/b&gt; and &lt;b&gt;LongAccumulator&lt;/b&gt;: Take a BinaryOperator
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;DoubleAdder&lt;/b&gt; and &lt;b&gt;LongAdder&lt;/b&gt;: provides analogy of the
functionality of the accumulators for the common special case of
maintaining counts and sums.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new LongAdder()&lt;/code&gt; is equivalent to &lt;br&gt;
    &lt;code&gt;new LongAccumulator ((x+y)-&amp;gt;x+y), 0l)&lt;/code&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java's low-level synchronisation mechanism impacts hardware
utilisation and scalability in the following ways:
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;Contended synchronisation&lt;/b&gt; where multiple threads constantly
competing for a lock, is expensive and throughput suffers as a result.
&lt;ul class="org-ul"&gt;
&lt;li&gt;The expense is caused mainly by the frequent &lt;b&gt;context switching&lt;/b&gt;.
&lt;/li&gt;
&lt;li&gt;Each &lt;b&gt;context switch&lt;/b&gt; operation can take many processor cycles to
complete.
&lt;/li&gt;
&lt;li&gt;Modern JVM make &lt;b&gt;uncontended synchronisation&lt;/b&gt; inexpensive.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;When a thread holding a lock is delayed (because of a scheduling
delay for example), no thread that requires that lock makes any progress.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt; cannot be used as a synchronization alternative.
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt; variables only solve the visibility problem.
&lt;/li&gt;
&lt;li&gt;Cannot be used to safely implement the atomic &lt;b&gt;read-modify-write&lt;/b&gt;
    sequence.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Compare-and-Swap(CAS) is an &lt;b&gt;uninterruptible&lt;/b&gt; microprocessor specific
instruction that :
&lt;ol class="org-ol"&gt;
&lt;li&gt;Read value with an expected value,
&lt;/li&gt;
&lt;li&gt;Store a new value in the memory location if the read value matches
the expected value.
&lt;/li&gt;
&lt;li&gt;Otherwise, nothing is done.
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;CAS supports atomic &lt;b&gt;read-modify-write&lt;/b&gt; sequences:
&lt;ol class="org-ol"&gt;
&lt;li&gt;Read value &lt;code&gt;x&lt;/code&gt; from address &lt;code&gt;A&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;Perform a multistep computation on &lt;code&gt;x&lt;/code&gt; to drive a new value &lt;code&gt;y&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;Use CAS to change ghe value of &lt;code&gt;A&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;CAS succeeds when &lt;code&gt;A&lt;/code&gt;'s value hasn't changed while performing
these steps.
&lt;/li&gt;
&lt;li&gt;This is normally wrapped in a while loop to repeat until success.
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;ReentrantLock&lt;/b&gt; offers better performance than &lt;code&gt;synchronized&lt;/code&gt; under
high thread contention.
&lt;ul class="org-ul"&gt;
&lt;li&gt;its synchronization is managed by a subclass of
&lt;code&gt;java.util.concurrent.locks.AbstractQueuedSynchronizer&lt;/code&gt;,
&lt;/li&gt;
&lt;li&gt;which in turn, leverages the &lt;code&gt;sun.mics.Unsafe&lt;/code&gt; class and its
&lt;code&gt;compareAndSwapInt()&lt;/code&gt; CAS method.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The atomic variable classes also leverage CAS with a method:
&lt;code&gt;boolean compareAndSet(expectedValue, updateValue)&lt;/code&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-10" class="outline-3"&gt;
&lt;h3 id="sec-1-10"&gt;Fork/Join&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-10"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Fork/Join consists of a special &lt;b&gt;executor service&lt;/b&gt; and &lt;b&gt;thread
pool&lt;/b&gt;:
&lt;ul class="org-ul"&gt;
&lt;li&gt;The executor service makes a task available to the framework,
&lt;/li&gt;
&lt;li&gt;And this task is broken into smaller tasks that are forked
(executed by different threads) from the pool.
&lt;/li&gt;
&lt;li&gt;A task waits until joined (its subtasks finish).
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TODO
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-11" class="outline-3"&gt;
&lt;h3 id="sec-1-11"&gt;CompletionService&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-11"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;A service that decouples the production of new tasks from the
consumption of the tasks' results &lt;b&gt;in the order&lt;/b&gt; they complete.
&lt;ul class="org-ul"&gt;
&lt;li&gt;Producer &lt;code&gt;submit&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;Consumer &lt;code&gt;poll&lt;/code&gt; or &lt;code&gt;take&lt;/code&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;poll()&lt;/code&gt; : Retrieves and removes the Future representing the next
completed task, or &lt;code&gt;null&lt;/code&gt; if none are present.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;poll(long timeout, TimeUnit unit)&lt;/code&gt;: waiting if necessary.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;take()&lt;/code&gt; : block if none are yet present.
&lt;/li&gt;
&lt;li&gt;Difference between executor service and completion service:
&lt;ul class="org-ul"&gt;
&lt;li&gt;ExecutorService provides an incoming queue for tasks and provides
workers threads.
&lt;/li&gt;
&lt;li&gt;CompletionService provides an incoming queue for tasks, worker
threads, &lt;b&gt;and&lt;/b&gt; an output queue for storing task results.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-12" class="outline-3"&gt;
&lt;h3 id="sec-1-12"&gt;Testing Concurrent Applications&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-12"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Monitoring &lt;b&gt;ReentrantLock&lt;/b&gt; with its methods:
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;protected Thead getOwner()&lt;/code&gt; : return the Thread that currently
owns this lock, or null if not owned.
&lt;ul class="org-ul"&gt;
&lt;li&gt;Noticed that this is a protected method, so to use it one will
need to extend.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;protected getQueuedThreads()&lt;/code&gt; : return the collection containing
the threads that may be waiting to acquire this lock.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;protected getWaitingThreads(Condition condition)&lt;/code&gt; : return the
collection containing the threads that may be waiting ont he given
condition associated with this lock.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isHeldbycurrentthread()&lt;/code&gt; queries if this lock is hold by the
current thread.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isLocked()&lt;/code&gt; : indicating if this lock is owned by a thread.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;MultithreadedTC&lt;/b&gt; is a library for testing concurrent application.
&lt;ul class="org-ul"&gt;
&lt;li&gt;It features a &lt;b&gt;metronome/clock&lt;/b&gt; that is used to provide &lt;b&gt;fine control&lt;/b&gt;
    over &lt;b&gt;the sequence of activities&lt;/b&gt; in multiple threads.
&lt;/li&gt;
&lt;li&gt;It supports test cases that execise a &lt;b&gt;specific&lt;/b&gt; interleaving of
the threads.
&lt;/li&gt;
&lt;li&gt;It is motivited by the &lt;b&gt;principle&lt;/b&gt; that &lt;i&gt;cuncurrent application
shoul be built using &lt;b&gt;small concurrent abstractions&lt;/b&gt;&lt;/i&gt; such as
&lt;i&gt;bounded buffers&lt;/i&gt;, &lt;i&gt;semaphores&lt;/i&gt; and &lt;i&gt;latches&lt;/i&gt;.
&lt;ul class="org-ul"&gt;
&lt;li&gt;Separating the concurrency logic from the rest of the application
logic in this way makes it easier to understand and test
concurrent applications.
&lt;/li&gt;
&lt;li&gt;Since these abstractions are small, it should be possible to
&lt;b&gt;deterministically&lt;/b&gt; test every &lt;b&gt;significant&lt;/b&gt; interleaving in
separate tests.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;It uses an internal clock:
&lt;ul class="org-ul"&gt;
&lt;li&gt;the clock only advances to the next tick when all threads are
blocked.
&lt;/li&gt;
&lt;li&gt;waitForTick(1) : makes thread block until the clock reaches tick
1 before assuming. The interger received in this method is used
to control the order of execution.
&lt;/li&gt;
&lt;li&gt;assertTick(1) : assert that the clock is in tick 1.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>concurrency</category><category>java</category><guid>https://example.com/posts/notes/java-concurrency/</guid><pubDate>Thu, 13 Jul 2017 23:00:00 GMT</pubDate></item></channel></rss>