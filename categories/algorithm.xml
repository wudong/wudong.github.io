<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Warren Liu (Posts about algorithm)</title><link>https://wudong.graceliu.uk/</link><description></description><atom:link href="https://wudong.graceliu.uk/categories/algorithm.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2017 &lt;a href="mailto:wudong@graceliu.uk"&gt;Warren Liu&lt;/a&gt; </copyright><lastBuildDate>Thu, 20 Jul 2017 21:01:23 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Deep Learning in Python</title><link>https://wudong.graceliu.uk/posts/courses/deep-learning-in-python/</link><dc:creator>Warren Liu</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/courses/deep-learning-in-python/#sec-1"&gt;Data Pre-processing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Data Pre-processing&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Logistic regression / neural networks work on numerical vectors, not
categories.
&lt;/li&gt;
&lt;li&gt;One-hot encoding, to change a categories to  numerical values:
For example, Time of day is a category of 4: 0, 1, 2, 3, it can be
encoded as:
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="right"&gt;

&lt;col class="right"&gt;

&lt;col class="right"&gt;

&lt;col class="right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="right"&gt;12am-6am&lt;/th&gt;
&lt;th scope="col" class="right"&gt;6am-12pm&lt;/th&gt;
&lt;th scope="col" class="right"&gt;12pm-6pm&lt;/th&gt;
&lt;th scope="col" class="right"&gt;6pm-12am&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="right"&gt;1&lt;/td&gt;
&lt;td class="right"&gt;0&lt;/td&gt;
&lt;td class="right"&gt;0&lt;/td&gt;
&lt;td class="right"&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="right"&gt;0&lt;/td&gt;
&lt;td class="right"&gt;1&lt;/td&gt;
&lt;td class="right"&gt;0&lt;/td&gt;
&lt;td class="right"&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="right"&gt;0&lt;/td&gt;
&lt;td class="right"&gt;0&lt;/td&gt;
&lt;td class="right"&gt;1&lt;/td&gt;
&lt;td class="right"&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="right"&gt;0&lt;/td&gt;
&lt;td class="right"&gt;0&lt;/td&gt;
&lt;td class="right"&gt;0&lt;/td&gt;
&lt;td class="right"&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
Having a 1 for each column.
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Binary categories don't need 2 columns for "true" and "false". Just
absorb the "false" into the bias term.
&lt;/li&gt;
&lt;li&gt;Numerical columns: &lt;br&gt;
  Simple way to normalization (0 mean, 1 standard deviation): minus
the mean and devided by the deviation.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>algorithm</category><category>deep learning</category><category>python</category><guid>https://wudong.graceliu.uk/posts/courses/deep-learning-in-python/</guid><pubDate>Mon, 17 Jul 2017 23:00:00 GMT</pubDate></item><item><title>Thoughtful machine learning</title><link>https://wudong.graceliu.uk/posts/reading/thoughtful-machine-learning/</link><dc:creator>Warren Liu</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/reading/thoughtful-machine-learning/#sec-1"&gt;K-Nearest Neighbours Classification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/reading/thoughtful-machine-learning/#sec-2"&gt;Naive Bayesian Classification&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/reading/thoughtful-machine-learning/#sec-2-0-1"&gt;Spam Filter using naive bayesian classification&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/reading/thoughtful-machine-learning/#sec-3"&gt;Nerual Networks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/reading/thoughtful-machine-learning/#sec-4"&gt;Hidden Markov Models&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;K-Nearest Neighbours Classification&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
K-Nearest Neighbour is one of the best algorithms for classifying data
sets. It is lazy and nonparametric.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;A &lt;b&gt;perceptual hash (pHash)&lt;/b&gt; is a fingerprint of a multimedia file
derived from various features from its content. Unlike cryptographic
hash functions, where small changes in input leading to drastic
changes in the putput, &lt;span class="underline"&gt;perceptual hashes are "close" to another if
the features are similar&lt;/span&gt;.
&lt;/li&gt;
&lt;li&gt;Hamming distance: between two strings of equal length is the number
of positions at which the corresponding symbols are different. It
measures the minimum number of substitutions required to change one
string into the other.
&lt;/li&gt;
&lt;li&gt;How to pick K:
&lt;ul class="org-ul"&gt;
&lt;li&gt;It is usually domain specific;
&lt;/li&gt;
&lt;li&gt;Choose a K that is low enough to avoid noise;
&lt;/li&gt;
&lt;li&gt;Iterate through a couple of possbile Ks unitl finding a suitable
error with &lt;b&gt;cross validation&lt;/b&gt;, given the training set.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;Naive Bayesian Classification&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;Conditional Probablities&lt;/b&gt; is a measure of the probablitity of an
event given that another event has occured:
&lt;p&gt;
\begin{equation} P(A|B) = \frac{P(A \cap B)}{P(B)} \end{equation}
Note that this is a &lt;b&gt;definition but not a theoretical result&lt;/b&gt;. We just
denote the quantity \(P(A\cap B)/P(B)\) as \(P(A|B)\)
and call it the conditional probability of A given B.
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;In statistical inference, &lt;b&gt;Conditional Probablities&lt;/b&gt; is an update of
the probablitity of an event based on new information.
&lt;/li&gt;
&lt;li&gt;Inverse conditional probablity (aka Bayes's Theorem):
&lt;p&gt;
\begin{equation} P(A\mid B) = \frac{P(B \mid A) \, P(A)}{P(B)}
\end{equation}
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Naive Bayesian classifier assume the independence assumptions
between the features.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2-0-1" class="outline-4"&gt;
&lt;h4 id="sec-2-0-1"&gt;Spam Filter using naive bayesian classification&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-0-1"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;A tokenizer to extract words into a stream, instead of an array, to
keep a low memory usage.
&lt;/li&gt;
&lt;li&gt;For all word in each training email, the filter will adjust the
probabilities each word will appear in spam or ham.
&lt;/li&gt;
&lt;li&gt;The word probablities (also known as likelihood functions) are used
to compute the probablitity that an email with a particular set of
words in it belongs to either category.
&lt;/li&gt;
&lt;li&gt;With the native bayesian classification, the score for spam based on
word can be simplified as:
\begin{equation}
  Score(spam, W_1, W_2, ..., W_n) = P(spam)P(W_1|spam)P(W_2|spam)...P(W_n|spam)
\end{equation}
&lt;p&gt;
which is then divided some normalizing constant Z.
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Cross-validation to minimizing false positives (instead of error)
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;Nerual Networks&lt;/h2&gt;
&lt;/div&gt;


&lt;div id="outline-container-sec-4" class="outline-2"&gt;
&lt;h2 id="sec-4"&gt;Hidden Markov Models&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
Hidden Markov Models can be either supervised or unsupervised, and
also are called Markovian due to theire reliance on a Markov
Model. They work well where there doesn't need to be a lot of
historical information built into the model.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>algorithm</category><category>machine learning</category><guid>https://wudong.graceliu.uk/posts/reading/thoughtful-machine-learning/</guid><pubDate>Fri, 14 Jul 2017 23:00:00 GMT</pubDate></item><item><title>Coding Questions</title><link>https://wudong.graceliu.uk/posts/notes/coding-questions/</link><dc:creator>Warren Liu</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/coding-questions/#sec-1"&gt;Some Coding Questions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Some Coding Questions&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;String rotation: &lt;br&gt;
  Use &lt;b&gt;substring()&lt;/b&gt; only to determine if a string is a rotation
of the other.
&lt;/li&gt;

&lt;li&gt;Return k-th to last element (last k element) of a singlely linked list
&lt;/li&gt;

&lt;li&gt;Delete middle node in a singely linke list, given only access to
that node.
&lt;/li&gt;

&lt;li&gt;Partition a linked list around a value &lt;code&gt;x&lt;/code&gt;, so that the node that
has value smaller than &lt;code&gt;x&lt;/code&gt; comes before the those larger than &lt;code&gt;x&lt;/code&gt;.
&lt;/li&gt;

&lt;li&gt;
&lt;/li&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>algorithm</category><category>coding</category><guid>https://wudong.graceliu.uk/posts/notes/coding-questions/</guid><pubDate>Fri, 14 Jul 2017 15:28:48 GMT</pubDate></item><item><title>Algorithms Note</title><link>https://wudong.graceliu.uk/posts/notes/algorithms-notes/</link><dc:creator>Warren Liu</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-1"&gt;KdTree&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-1-1"&gt;Construction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-1-2"&gt;Adding elements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-1-3"&gt;Removing elements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-1-4"&gt;Nearest neighbour search with k-d tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-2"&gt;Selection algorithm&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-2-1"&gt;Selection by sorting.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-2-2"&gt;Partition based selection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-3"&gt;Dynamic Programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-4"&gt;Backtracking&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-4-1"&gt;Description of the method&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-4-2"&gt;The algorithm:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-5"&gt;Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-6"&gt;Threaded Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-7"&gt;Tires&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-7-1"&gt;The Problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-7-2"&gt;What is a Trie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-7-3"&gt;Complexity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-7-4"&gt;Example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wudong.graceliu.uk/posts/notes/algorithms-notes/#sec-8"&gt;SkipList&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;KdTree&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
&lt;a href="http://pointclouds.org/documentation/tutorials/kdtree_search.php"&gt;http://pointclouds.org/documentation/tutorials/kdtree_search.php&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
A k-d tree, or k-dimensional tree, is a data structure used for
organizing some number of points in a space with k-dimensions. It is a
&lt;b&gt;binary tree&lt;/b&gt; with some other constraints. K-d trees are very useful
for &lt;b&gt;range and nearest neighbor searches&lt;/b&gt;.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Every node in the binary tree is a k-dimensional point.
&lt;/li&gt;
&lt;li&gt;Each level of a k-d tree splits all children along a specific dimension.
&lt;/li&gt;
&lt;li&gt;Every non-leaf node can be thought of implicily generating a
splitting hyperplane that divides the space into two parts.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-1" class="outline-3"&gt;
&lt;h3 id="sec-1-1"&gt;Construction&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-1"&gt;
&lt;p&gt;
The pesduo code to construct a &lt;code&gt;balanced&lt;/code&gt; k-d tree, in which each leaf
node is approximately the same distance from the root.
&lt;/p&gt;

&lt;p class="verse"&gt;
function kdtree (list pointList, int depth)&lt;br&gt;
{&lt;br&gt;
    // Select axis based on depth so that axis cycles through all valid values&lt;br&gt;
    int axis := depth mod k;&lt;br&gt;
&lt;br&gt;
    // Sort point list and choose median as pivot element&lt;br&gt;
    select median by axis from pointList;&lt;br&gt;
&lt;br&gt;
    // Create node and construct subtrees&lt;br&gt;
    var tree&lt;sub&gt;node&lt;/sub&gt; node;&lt;br&gt;
    node.location := median;&lt;br&gt;
    node.leftChild := kdtree(points in pointList before median, depth+1);&lt;br&gt;
    node.rightChild := kdtree(points in pointList after median, depth+1);&lt;br&gt;
    return node;&lt;br&gt;
}&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
It is not required to select the median point for the
construction. When not, there is no gurantee the tree will be
balanced. To avoid a complex O(n) median-finding algorithms, on all n
points, a popular practice is to sort a &lt;code&gt;fixed number&lt;/code&gt; of randomly
selected points, and use the median of those point to server as the
splitting plane.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-2" class="outline-3"&gt;
&lt;h3 id="sec-1-2"&gt;Adding elements&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-2"&gt;
&lt;p&gt;
Same way as adding element to another search tree. Traverse the tree
to find the correct node under which to insert the node.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-3" class="outline-3"&gt;
&lt;h3 id="sec-1-3"&gt;Removing elements&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-3"&gt;
&lt;p&gt;
The easiest way is to form the set of all nodes and leaves from the
children of the target node, and recreate that part of the tree.
&lt;/p&gt;

&lt;p&gt;
Another way is to find a replacement for the node removed. And then
recursively remove the replacement.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-4" class="outline-3"&gt;
&lt;h3 id="sec-1-4"&gt;Nearest neighbour search with k-d tree&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-4"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;With the search point, finding the node that will be the insertion
node if it is to insert the search point into the tree, and save
the node as &lt;code&gt;current best&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;Unwinds the recursion of the tree, performing the following steps
at each node:
&lt;ol class="org-ol"&gt;
&lt;li&gt;If the current noe is closer than the &lt;code&gt;current best&lt;/code&gt;, it become
the &lt;code&gt;current best&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;The algorithm checks whether there could be any points on the
other side of the splitting plane that are closer to the search
point than the &lt;code&gt;current best&lt;/code&gt;.
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;Selection algorithm&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
A selection algorithm is to find the k-th smallest number in a
list. This includes the cases of finding minimum, maxmum and median
elements. There are O(n) selection algorithms and sublinear
performance for structured data.
&lt;/p&gt;

&lt;p&gt;
The best-known selection algorithm is &lt;b&gt;quickselect&lt;/b&gt;, related to
&lt;b&gt;quicksort&lt;/b&gt;. Like quicksort, &lt;span class="underline"&gt;it has optimal average performance, but
poor worst-case performance&lt;/span&gt;.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2-1" class="outline-3"&gt;
&lt;h3 id="sec-2-1"&gt;Selection by sorting.&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;This method is inefficient for selecting a single element, but is
efficient when many selections need to be made.
&lt;/li&gt;
&lt;li&gt;Partial sorting only for the k.
&lt;/li&gt;
&lt;li&gt;Partial selection sort.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2-2" class="outline-3"&gt;
&lt;h3 id="sec-2-2"&gt;Partition based selection&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Quickselect is a variant of quicksort: in both one chooses a pivot
and then partitions the data by it, but while quicksort recurses on
both sides of the partition, &lt;span class="underline"&gt;quickselect only recurses on one side&lt;/span&gt;,
namely the side on which the desired kth element is.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;Dynamic Programming&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Dynamic Programming is not an algorithm or data-structure. It is a
technique and it is applied to a certain class of problem.
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Divide&lt;/b&gt; a problem into smaller sub-problems and if there are some
&lt;b&gt;overlapping&lt;/b&gt; sub-problems, then it is a dynamic programming problem.
&lt;/li&gt;
&lt;li&gt;The core idea of DP is to &lt;i&gt;avoid repeated work&lt;/i&gt; by remembering &lt;b&gt;partial&lt;/b&gt;
  results. It is basically &lt;b&gt;recursion along with memorisation&lt;/b&gt;.
&lt;ul class="org-ul"&gt;
&lt;li&gt;Recursion allows expressing the value of a function in terms of
other values of that function.
&lt;/li&gt;
&lt;li&gt;Memorisation tells that if the recursive calls were done in
advanced, and stored for access, it will make the program faster.
&lt;/li&gt;
&lt;li&gt;The intuition behind is to trade space for time.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DP is a powerful technique that allows one to solver different types
of problems in time \(O(n^2)\) or \(O(n^3)\) while a naive approach would
take exponential time.
&lt;/li&gt;
&lt;li&gt;An example for Fibonacci function.
&lt;ul class="org-ul"&gt;
&lt;li&gt;With pure recursive:
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;fib&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;Bottom-up iterative approach:
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;fib&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;fibresult&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;fibresult&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="n"&gt;fibresult&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fibresult&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fibresult&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;With DP, recursive approach with memorisation:
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;maxn&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;solve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    &lt;span class="c1"&gt;// base conditions&lt;/span&gt;
	&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    &lt;span class="c1"&gt;// if memoized then return the value&lt;/span&gt;
	&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;solve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;solve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// recursive definition&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Solve &lt;code&gt;Edit Distance&lt;/code&gt; using DP:
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;Edit Distance&lt;/code&gt; is a way of quantifying how dissimilar two strings
are, i.e. how many operations(add, delete, or replace a single
character) it would take to transform one string to the other.
&lt;/li&gt;
&lt;li&gt;Solving using DP, using a matrix to save the partial result:
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;editDistance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;// for all i, j, dp[i][j] will hold the edit distance between the first&lt;/span&gt;
    &lt;span class="c1"&gt;// i characters of source string and first j characters of target string&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="c1"&gt;// source can be transformed into target prefix by inserting&lt;/span&gt;
    &lt;span class="c1"&gt;// all of the characters in the prefix&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// source prefixes can be transformed into empty string by&lt;/span&gt;
    &lt;span class="c1"&gt;// by deleting all of the characters&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
		&lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// no operation required as characters are the same&lt;/span&gt;
	    &lt;span class="p"&gt;}&lt;/span&gt;
	    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
		&lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;    &lt;span class="c1"&gt;// substitution&lt;/span&gt;
			       &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;     &lt;span class="c1"&gt;// insertion&lt;/span&gt;
				    &lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]));&lt;/span&gt;    &lt;span class="c1"&gt;// deletion&lt;/span&gt;
	    &lt;span class="p"&gt;}&lt;/span&gt;
	&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-4" class="outline-2"&gt;
&lt;h2 id="sec-4"&gt;Backtracking&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Backtracking incrementally builds candidates to the solutions, and
abandon each partial candidate as soon as it cannot possibly be
completed to a valid solution.
&lt;/li&gt;
&lt;li&gt;Backtracking can be applied only for problems which admit the
concept of a &lt;b&gt;partial candidate solution&lt;/b&gt; and a relatively quick
test of whether it can possibly be completed to a valid solution.
&lt;/li&gt;
&lt;li&gt;When it applicable, it often much faster than brute force
enumeration of all complete candidates, since it eliminate a large
number of candidates with a single test.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-4-1" class="outline-3"&gt;
&lt;h3 id="sec-4-1"&gt;Description of the method&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-4-1"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Conceptually, the partial candidates are represented as the &lt;b&gt;nodes&lt;/b&gt; of
a &lt;b&gt;tree&lt;/b&gt; structure, &lt;i&gt;the potential search tree&lt;/i&gt;.
&lt;/li&gt;
&lt;li&gt;Each partial candidate is the parent of the candidates that &lt;i&gt;differ
from it by a &lt;b&gt;single extension step&lt;/b&gt;&lt;/i&gt;;
&lt;/li&gt;
&lt;li&gt;The &lt;b&gt;leaves&lt;/b&gt; of the tree are the partial candidates that cannot be
extended any further, i.e, a possible solution.
&lt;/li&gt;
&lt;li&gt;The backtracking algorithm traverses this search tree recursively,
from the root down, in &lt;b&gt;depth-first&lt;/b&gt; order.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-4-2" class="outline-3"&gt;
&lt;h3 id="sec-4-2"&gt;The algorithm:&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-4-2"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://www.cis.upenn.edu/~matuszek/cit594-2012/Pages/backtracking.html"&gt;The tutorial&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;Recursive code:
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;solve&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;is_leaf&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;is_goal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;child&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
	&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;solve&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
The reasoning:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;If any of the children of n is solvable, n is solvable
&lt;/li&gt;
&lt;li&gt;If non of the children of n is solvable, n is non-solvable
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Non-Recursive code:
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;solve&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;push&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;(!&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isEmpty&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;peek&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;is_leaf&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;)){&lt;/span&gt;
	&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;is_goal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;)){&lt;/span&gt;
	    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
	&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
	    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;pop&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
	&lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
	&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hasMoreChildToTry&lt;/span&gt;&lt;span class="o"&gt;()){&lt;/span&gt;
	    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;childNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;nextChild&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
	    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;push&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;childNode&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
	&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
	    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;pop&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
	&lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;};&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
When the stack algorithm terminates successfully, the nodes on the
stack form (in reverse order) a path from the root to a goal node.
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-5" class="outline-2"&gt;
&lt;h2 id="sec-5"&gt;Binary Tree&lt;/h2&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-6" class="outline-2"&gt;
&lt;h2 id="sec-6"&gt;Threaded Binary Tree&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-6"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;A binary tree is threaded by :
&lt;ul class="org-ul"&gt;
&lt;li&gt;all right child pointers that would normally be &lt;b&gt;null&lt;/b&gt; point to
the &lt;b&gt;inorder&lt;/b&gt; successor of the node (if it exists).
&lt;/li&gt;
&lt;li&gt;all left child pointers that would normally be &lt;b&gt;null&lt;/b&gt; point to
the inorder &lt;b&gt;predecessor&lt;/b&gt; of the node.
&lt;/li&gt;
&lt;li&gt;Need to know if a pointer is a link or a thread, so a boolean is
needed for each pointer.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Binary tree have a lot of wasted space. the null pointers can be
used to help &lt;b&gt;inorder&lt;/b&gt; traversals.
&lt;/li&gt;
&lt;li&gt;Threaded binary tree makes tree traversal faster since no stack or
recursion is needed.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-7" class="outline-2"&gt;
&lt;h2 id="sec-7"&gt;Tires&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-7"&gt;
&lt;/div&gt;&lt;div id="outline-container-sec-7-1" class="outline-3"&gt;
&lt;h3 id="sec-7-1"&gt;The Problem&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-7-1"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Determine if a word appears in a large dictionary. How to store the
large set of words in the dictionary effectively.
&lt;/li&gt;
&lt;li&gt;Google auto complete can also be implemented with a trie.
&lt;/li&gt;
&lt;li&gt;We can use &lt;b&gt;Trie&lt;/b&gt; and &lt;b&gt;Min Heap&lt;/b&gt; to get the &lt;code&gt;k&lt;/code&gt; most frequent words
efficiently.
&lt;ul class="org-ul"&gt;
&lt;li&gt;The idea is to use &lt;b&gt;Trie&lt;/b&gt; for searching existing words
adding new words efficiently.
&lt;/li&gt;
&lt;li&gt;Trie also stores count of occurrences of words.
&lt;/li&gt;
&lt;li&gt;A &lt;b&gt;Min Heap&lt;/b&gt; of size &lt;code&gt;k&lt;/code&gt; is used to keep track of &lt;code&gt;k&lt;/code&gt; most frequent
words at any point of time(Use of Min Heap is same as we used it
to find &lt;code&gt;k&lt;/code&gt; largest elements in this post).
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Can be used for many other cases for example, to store a large set
of &lt;b&gt;Integer&lt;/b&gt;, &lt;b&gt;ByteArray&lt;/b&gt;, etc.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-7-2" class="outline-3"&gt;
&lt;h3 id="sec-7-2"&gt;What is a Trie&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-7-2"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;The trie is a tree where each vertex represents a single word or a
prefix.
&lt;/li&gt;
&lt;li&gt;The root represents an empty string (“”), the vertexes that are
direct sons of the root represent prefixes of length &lt;code&gt;1&lt;/code&gt;. A vertex
that are &lt;code&gt;k&lt;/code&gt; edges of distance of the root have an associated prefix
of length &lt;code&gt;k&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;Let &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; be two vertexes of the trie, and assume that &lt;code&gt;v&lt;/code&gt; is a
direct father of &lt;code&gt;w&lt;/code&gt;, then &lt;code&gt;v&lt;/code&gt; must have an associated prefix of &lt;code&gt;w&lt;/code&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-7-3" class="outline-3"&gt;
&lt;h3 id="sec-7-3"&gt;Complexity&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-7-3"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Insert/Finding of a word in tire can be done in &lt;code&gt;O(L)&lt;/code&gt; time, where L
is the length of the word.
&lt;/li&gt;
&lt;li&gt;The memory used in the tries depends on the methods to store the
edges and how many words have prefixes in common.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-7-4" class="outline-3"&gt;
&lt;h3 id="sec-7-4"&gt;Example&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-7-4"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;The next figure shows a trie with the words “tree”, “trie”, “algo”,
“assoc”, “all”, and “also.”
&lt;img src="http://community.topcoder.com/i/education/alg_tries.png" alt="alg_tries.png"&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;/li&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-8" class="outline-2"&gt;
&lt;h2 id="sec-8"&gt;SkipList&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-8"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;SkipList is a data structure that allows fast search within an ordered
sequence of elements.
&lt;img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/86/Skip_list.svg/400px-Skip_list.svg.png" alt="400px-Skip_list.svg.png"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;By maintaining a linked hierarchy of subsequences, with each
successive subsequences skipping over fewer elements than the
previous one.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Search/Insert/Delete average on &lt;code&gt;O(log n)&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;A skip list is built in layers:
&lt;ul class="org-ul"&gt;
&lt;li&gt;The bottom layer is an ordinary ordered linked list.
&lt;/li&gt;
&lt;li&gt;Each higher layer acts as an "express lane" for the lists below,
where an element in layer &lt;code&gt;i&lt;/code&gt; appears in layer &lt;code&gt;i+1&lt;/code&gt; with some fixed
probability &lt;code&gt;p&lt;/code&gt; (two commonly used values for p are 1/2 or 1/4).
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A search for a target element begins at the head element in the top
list, and proceeds horizontally until the current element is greater
than or equal to the target.
&lt;ul class="org-ul"&gt;
&lt;li&gt;if equal, it is found.
&lt;/li&gt;
&lt;li&gt;if greater, or search reaches the end of the linked list, the
procedure is repeated after returning to the previous element and
dropping down vertically to the next lower list.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>algorithm</category><guid>https://wudong.graceliu.uk/posts/notes/algorithms-notes/</guid><pubDate>Thu, 13 Jul 2017 23:00:00 GMT</pubDate></item></channel></rss>